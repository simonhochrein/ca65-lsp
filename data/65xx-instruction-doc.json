{
  "keys_to_doc": {
    "clv": "Clear Status Flags\n==================\n\n**Flags affected (`CLC`)**: `-------c`\n\n**Flags affected (`CLD`)**: `----d---`\n\n**Flags affected (`CLI`)**: `-----i--`\n\n**Flags affected (`CLV`)**: `-v------`\n\n**CLC:**\n\n`c` ← `0`\n\n**CLD:**\n\n`d` ← `0`\n\n**CLI:**\n\n`i` ← `0`\n\n**CLV:**\n\n`v` ← `0`\n\n---\nSyntax          | Name                      | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`CLC`             | Clear Carry Flag          | `$18`   | 1     | 2\n`CLI`             | Clear Interrupt Disable Flag | `$58`| 1     | 2\n`CLD`             | Clear Decimal Flag        | `$D8`   | 1     | 2\n`CLV`             | Clear Overflow Flag       | `$B8`   | 1     | 2\n",
    "dey": "DEX, DEY - Decrement Index Registers\n====================================\n\n**Flags affected**: `n-----z-`\n\n`R` ← `R - 1`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`DEX`             | Implied                   | `$CA`   | 1     | 2\n`DEY`             | Implied                   | `$88`   | 1     | 2\n",
    "iny": "INX, INY - Increment Index Registers\n====================================\n\n**Flags affected**: `n-----z-`\n\n`R` ← `R + 1`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`INX`             | Implied                   | `$E8`   | 1     | 2\n`INY`             | Implied                   | `$C8`   | 1     | 2\n",
    "wai": "WAI - Wait for Interrupt\n========================\n\n**Flags affected**: `--------`\n\n`RDY pin` ← `0`\n\n`wait for NMI, IRQ or ABORT signal`\n\n`execute interrupt handler if interrupt is not masked`\n\n`RDY pin` ← `1`\n\nWhen the `RDY` (Ready) pin is pulled low the processor enters a low\npower mode.\n\nThis instruction is useful when you want as little delay as possible\nbetween the interrupt signal and the processor executing the interrupt\nhandler.\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`WAI`             | Implied                   | `$CB`   | 1     | 3 | additional cycles needed by interrupt handler to restart the processor\n",
    "sei": "Set Status Flags\n================\n\n**Flags affected (`SEC`)**: `-------c`\n\n**Flags affected (`SED`)**: `----d---`\n\n**Flags affected (`SEI`)**: `-----i--`\n\n**SEC:**\n\n`c` ← `1`\n\n**SED:**\n\n`d` ← `1`\n\n**SEI:**\n\n`i` ← `1`\n---\nSyntax          | Name                      | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`SEC`             | Set Carry Flag            | `$38`   | 1     | 2\n`SEI`             | Set Interrupt Disable Flag | `$78`  | 1     | 2\n`SED`             | Set Decimal Flag          | `$F8`   | 1     | 2\n",
    "ora": "ORA - OR Accumulator with Memory\n================================\n\n**Flags affected**: `n-----z-`\n\n`A` ← `A | M`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`ORA #const`      | Immediate                 | `$09`   | 2 / 3 | 2 |\n`ORA addr`        | Absolute                  | `$0D`   | 3     | 4 |\n`ORA long`        | Absolute Long             | `$0F`   | 4     | 5 |\n`ORA dp`          | Direct Page               | `$05`   | 2     | 3 |\n`ORA (dp)`        | Direct Page Indirect      | `$12`   | 2     | 5 |\n`ORA [dp]`        | Direct Page Indirect Long | `$07`   | 2     | 6 |\n`ORA addr, X`     | Absolute Indexed, X       | `$1D`   | 3     | 4 |\n`ORA long, X`     | Absolute Long Indexed, X  | `$1F`   | 4     | 5 |\n`ORA addr, Y`     | Absolute Indexed, Y       | `$19`   | 3     | 4 |\n`ORA dp, X`       | Direct Page Indexed, X    | `$15`   | 2     | 4 |\n`ORA (dp, X)`     | Direct Page Indirect, X   | `$01`   | 2     | 6 |\n`ORA (dp), Y`     | DP Indirect Indexed, Y    | `$11`   | 2     | 5 |\n`ORA [dp], Y`     | DP Indirect Long Indexed, Y | `$17` | 2     | 6 |\n`ORA sr, S`       | Stack Relative            | `$03`   | 2     | 4 |\n`ORA (sr, S), Y`  | SR Indirect Indexed, Y    | `$13`   | 2     | 7 |\n",
    "xce": "XCE - Exchange Carry and Emulation Bits\n=======================================\n\n**Flags affected**: `--mx---c : e`\n\n`c` ← Previous `e` flag\n\n`e` ← Previous `c` flag\n\n\n\n\n**if e is set (Emulation Mode):**\n\n`m` ← `1`\n\n`x` ← `1`\n\n`S.h` ← `0x01`\n\n`X.h` ← `0x00`\n\n`Y.h` ← `0x00`\n\nNote: The high byte of the Stack Pointer is fixed in emulation mode.\n\nNote: Emulation mode will set bit 4 (x) of the status register, which will also set the high byte of the index registers to 0.\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`XCE`             | Implied                   | `$FB`   | 1     | 2 |\n",
    "wdm": "WDM - Reserved for Future Expansion\n===================================\n\n**Flags affected**: `--------`\n\n&mdash;\n\nOn the SNES it does nothing. This instruction should not be used in your\nprogram.\n\nThe bsnes-plus and Mesen-S debuggers have a setting that changes `WDM`\ninstructions into software breakpoints.\n\nThis instruction has a non-standard syntax.  Some assemblers will use `wdm #1`,\nwhile other assemblers use `wdm 1`.\n",
    "rep": "REP - Reset Status Bits\n=======================\n\n**Flags affected**: `nvmxdizc`\n\n**Native Mode:**\n\n`P` ← `P & (~M)`\n\n**Emulation Mode:**\n\n`P` ← `P & (~M)`\n\n`x` ← `1`\n\n`m` ← `1`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`REP #const`      | Immediate                 | `$C2`   | 2     | 3\n",
    "brl": "Branches\n========\n\n**Flags affected**: `--------`\n\n**Branch not taken:**\n\n&mdash;\n\n**Branch taken:**\n\n`PC` ← `PC + sign-extend(near)`\n\n**Branch taken (BRL):**\n\n`PC` ← `PC + label`\n\n---\nSyntax          | Name                      | Condition       |     | Opcode| Bytes | Cycles |\n----------------|---------------------------|-----------------|-----|-------|-------|--------|\n`BCC near`        | Branch if Carry Clear     | carry clear     | c=0 | `$90`   | 2     | 2 |\n`BCS near`        | Branch if Carry Set       | carry set       | c=1 | `$B0`   | 2     | 2 |\n`BNE near`        | Branch if Not Equal       | zero clear      | z=0 | `$D0`   | 2     | 2 |\n`BEQ near`        | Branch if Equal           | zero set        | z=1 | `$F0`   | 2     | 2 |\n`BPL near`        | Branch if Plus            | negative clear  | n=0 | `$10`   | 2     | 2 |\n`BMI near`        | Branch if Minus           | negative set    | n=1 | `$30`   | 2     | 2 |\n`BVC near`        | Branch if Overflow Clear  | overflow clear  | v=0 | `$50`   | 2     | 2 |\n`BVS near`        | Branch if Overflow Set    | overflow set    | v=1 | `$70`   | 2     | 2 |\n`BRA near`        | Branch Always             | always          |     | `$80`   | 2     | 3 |\n`BRL label`       | Branch Always Long        | always          |     | `$82`   | 3     | 4\n",
    "cpx": "CPX - Compare Index Register X with Memory\n==========================================\n\n**Flags affected**: `n-----zc`\n\n`X - M`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero (Set if `X == M`)\n\n`c` ← Carry from ALU (Set if `X >= M`)\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`CPX #const`      | Immediate                 | `$E0`   | 2 / 3 | 2 |\n`CPX addr`        | Absolute                  | `$EC`   | 3     | 4 |\n`CPX dp`          | Direct Page               | `$E4`   | 2     | 3 |\n",
    "sep": "SEP - Set Status Bits\n=====================\n\n**Flags affected**: `nvmxdizc`\n\n`P` ← `P | M`\n\nNOTE: If bit 4 (x) of the status register is set, then the high byte of\nthe index registers will be set to 0.\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`SEP #const`      | Immediate                 | `$E2`   | 2     | 3\n",
    "cmp": "CMP - Compare Accumulator with Memory\n================================\n\n**Flags affected**: `n-----zc`\n\n`A - M`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero (Set if A == M)\n\n`c` ← Carry from ALU (Set if A >= M)\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`CMP #const`      | Immediate                 | `$C9`   | 2 / 3 | 2 |\n`CMP addr`        | Absolute                  | `$CD`   | 3     | 4 |\n`CMP long`        | Absolute Long             | `$CF`   | 4     | 5 |\n`CMP dp`          | Direct Page               | `$C5`   | 2     | 3 |\n`CMP (dp)`        | Direct Page Indirect      | `$D2`   | 2     | 5 |\n`CMP [dp]`        | Direct Page Indirect Long | `$C7`   | 2     | 6 |\n`CMP addr, X`     | Absolute Indexed, X       | `$DD`   | 3     | 4 |\n`CMP long, X`     | Absolute Long Indexed, X  | `$DF`   | 4     | 5 |\n`CMP addr, Y`     | Absolute Indexed, Y       | `$D9`   | 3     | 4 |\n`CMP dp, X`       | Direct Page Indexed, X    | `$D5`   | 2     | 4 |\n`CMP (dp, X)`     | Direct Page Indirect, X   | `$C1`   | 2     | 6 |\n`CMP (dp), Y`     | DP Indirect Indexed, Y    | `$D1`   | 2     | 5 |\n`CMP [dp], Y`     | DP Indirect Long Indexed, Y | `$D7` | 2     | 6 |\n`CMP sr, S`       | Stack Relative            | `$C3`   | 2     | 4 |\n`CMP (sr, S), Y`  | SR Indirect Indexed, Y    | `$D3`   | 2     | 7 |\n",
    "nop": "NOP - No Operation\n==================\n\n**Flags affected**: `--------`\n\n&mdash;\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`NOP`             | Implied                   | `$EA`   | 1     | 2 |\n",
    "rti": "RTI - Return From Interrupt\n===========================\n\n**Flags affected**: `nvmxdizc`\n\n**Native Mode:**\n`P` ← `[S+1]`\n`PC.l` ← `[S+2]`\n`PC.h` ← `[S+3]`\n`PBR` ← `[S+4]`\n`S` ← `S + 4`\n\n**Emulation Mode:**\n`P` ← `[S+1]`\n`x` ← `1`\n`m` ← `1`\n`PC.l` ← `[S+2]`\n`PC.h` ← `[S+3]`\n`S` ← `S + 3`\n\nNote: If bit 4 (x) of the status register is set, then the high byte of\nthe index registers will be set to 0.\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`RTI`             | Stack (return interrupt)  | `$40`   | 1     | 6 |\n",
    "jsl": "JSR, JSL - Jump to Subroutine\n=============================\n\n**Flags affected**: `--------`\n\n**JSR:**\n`PC` ← `PC - 1`\n\n`S` ← `S - 2`\n\n`[S+2]` ← `PC.h`\n\n`[S+1]` ← `PC.l`\n\n`PC` ← `M`\n\n**JSL:**\n`PC` ← `PC - 1`\n\n`S` ← `S - 3`\n\n`[S+3]` ← `PBR`\n\n`[S+2]` ← `PC.h`\n\n`[S+1]` ← `PC.l`\n\n`PBR:PC` ← `M`\n\nNOTE: The `JSR (addr, X)` instruction will read the subroutine address from the Program Bank (`PBR`) (ie, `JSR {$8888, X}` will read 2 bytes from `PBR:{$8888 + X}`).\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`JSR addr`        | Absolute                  | `$20`   | 3     | 6\n`JSR (addr, X)`   | Absolute Indexed Indirect, X | `$FC`| 3     | 8\n`JSL long`        | Absolute Long             | `$22`   | 4     | 8\n",
    "trb": "TRB - Test and Reset Memory Bits Against Accumulator\n====================================================\n\n**Flags affected**: `------z-`\n\n`z` ← Set if logical AND of memory and Accumulator is zero\n\n---\n`M` ← `M & (~A)`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`TRB addr`        | Absolute                  | `$1C`   | 3     | 6 |\n`TRB dp`          | Direct Page               | `$14`   | 2     | 5 |\n",
    "eor": "EOR - Exclusive OR Accumulator with Memory\n==========================================\n\n**Flags affected**: `n-----z-`\n\n`A` ← `A ^ M`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`EOR #const`      | Immediate                 | `$49`   | 2 / 3 | 2 |\n`EOR addr`        | Absolute                  | `$4D`   | 3     | 4 |\n`EOR long`        | Absolute Long             | `$4F`   | 4     | 5 |\n`EOR dp`          | Direct Page               | `$45`   | 2     | 3 |\n`EOR (dp)`        | Direct Page Indirect      | `$52`   | 2     | 5 |\n`EOR [dp]`        | Direct Page Indirect Long | `$47`   | 2     | 6 |\n`EOR addr, X`     | Absolute Indexed, X       | `$5D`   | 3     | 4 |\n`EOR long, X`     | Absolute Long Indexed, X  | `$5F`   | 4     | 5 |\n`EOR addr, Y`     | Absolute Indexed, Y       | `$59`   | 3     | 4 |\n`EOR dp, X`       | Direct Page Indexed, X    | `$55`   | 2     | 4 |\n`EOR (dp, X)`     | Direct Page Indirect, X   | `$41`   | 2     | 6 |\n`EOR (dp), Y`     | DP Indirect Indexed, Y    | `$51`   | 2     | 5 |\n`EOR [dp], Y`     | DP Indirect Long Indexed, Y | `$57` | 2     | 6 |\n`EOR sr, S`       | Stack Relative            | `$43`   | 2     | 4 |\n`EOR (sr, S), Y`  | SR Indirect Indexed, Y    | `$53`   | 2     | 7 |\n",
    "mvp": "MVP - Block Move Previous\n=========================\n\nThis instruction is also known as **Block Move Positive**.\n\n**Flags affected**: `--------`\n\n**Parameters:**\n\n`X`: address of last source byte\n\n`Y`: address of last destination byte\n\n`C`: length - 1\n\n`DBR` ← `destBank`\n\n`repeat:`\n\n`T` ← `srcBank:X`\n\n`DBR:Y` ← `T`\n\n`X` ← `X - 1`\n\n`Y` ← `Y - 1`\n\n`C` ← `C - 1`\n\n`until C == 0xffff`\n\nNOTES:\n\n * The number of bytes transferred is `C + 1`.\n * After the transfer is complete:\n    * `DBR` = destination bank\n    * `C` = `0xFFFF`\n    * `X` = the byte before the start of the source block\n    * `Y` = the byte before the start of the destination block.\n * If bit 4 (x) of the status register is set, `MVP` will only be able\n   to access the first page of the source and destination banks.\n * Block move instructions can be interrupted.  The move will resume after the\n   <abbr title=\"Interrupt Service Routine\">ISR</abbr> returns, provided the\n   `C`, `X`, `Y` registers, Program Counter and `MVP` instruction are unchanged.\n * `MVP` should be used if the blocks could overlap and the destination address\n   is greater than (more positive[^mvp-more-positive] than) the source address.\n\n---\nSyntax                | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------------|---------------------------|-------|-------|--------|\n`MVP srcBank, destBank` | Block Move                | `$44`   | 3     |  | 7 per byte moved\n\n\n[^mvp-more-positive]: MVP more positive source: W65C816S 8/16–bit Microprocessor Datasheet,\n    Table 5-7 Instruction Operation, 9b Block Move Positive,\n    by Western Design Center, Inc\n",
    "lsr": "LSR - Logical Shift Right\n=========================\n\n**Flags affected**: `n-----zc`\n\n`M` ← `M >> 1`\n\n---\n`n` ← cleared\n\n`z` ← Set if the result is zero\n\n`c` ← Bit 0 of original memory\n\nNOTE: This is an unsigned operation, the MSB of the result is always 0.\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`LSR`             | Accumulator               | `$4A`   | 1     | 2\n`LSR addr`        | Absolute                  | `$4E`   | 3     | 6 |\n`LSR dp`          | Direct Page               | `$46`   | 2     | 5 |\n`LSR addr, X`     | Absolute Indexed, X       | `$5E`   | 3     | 7 |\n`LSR dp, X`       | Direct Page Indexed, X    | `$56`   | 2     | 6 |\n",
    "adc": "ADC - Add with Carry\n====================\n\n**Flags affected**: `nv----zc`\n\n`A` ← `A + M + c`\n\n`n` ← Most significant bit of result\n\n`v` ← Signed overflow of result\n\n`z` ← Set if the result is zero\n\n`c` ← Carry from ALU (bit 8/16 of result)\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`ADC #const`      | Immediate                 | `$69`   | 2 / 3 | 2 |\n`ADC addr`        | Absolute                  | `$6D`   | 3     | 4 |\n`ADC long`        | Absolute Long             | `$6F`   | 4     | 5 |\n`ADC dp`          | Direct Page               | `$65`   | 2     | 3 |\n`ADC (dp)`        | Direct Page Indirect      | `$72`   | 2     | 5 |\n`ADC [dp]`        | Direct Page Indirect Long | `$67`   | 2     | 6 |\n`ADC addr, X`     | Absolute Indexed, X       | `$7D`   | 3     | 4 |\n`ADC long, X`     | Absolute Long Indexed, X  | `$7F`   | 4     | 5 |\n`ADC addr, Y`     | Absolute Indexed, Y       | `$79`   | 3     | 4 |\n`ADC dp, X`       | Direct Page Indexed, X    | `$75`   | 2     | 4 |\n`ADC (dp, X)`     | Direct Page Indirect, X   | `$61`   | 2     | 6 |\n`ADC (dp), Y`     | DP Indirect Indexed, Y    | `$71`   | 2     | 5 |\n`ADC [dp], Y`     | DP Indirect Long Indexed, Y | `$77` | 2     | 6 |\n`ADC sr, S`       | Stack Relative            | `$63`   | 2     | 4 |\n`ADC (sr, S), Y`  | SR Indirect Indexed, Y    | `$73`   | 2     | 7 |\n",
    "and": "AND - And Accumulator with Memory\n=================================\n\n**Flags affected**: `n-----z-`\n\n`A` ← `A & M`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`AND #const`      | Immediate                 | `$29`   | 2 / 3 | 2 |\n`AND addr`        | Absolute                  | `$2D`   | 3     | 4 |\n`AND long`        | Absolute Long             | `$2F`   | 4     | 5 |\n`AND dp`          | Direct Page               | `$25`   | 2     | 3 |\n`AND (dp)`        | Direct Page Indirect      | `$32`   | 2     | 5 |\n`AND [dp]`        | Direct Page Indirect Long | `$27`   | 2     | 6 |\n`AND addr, X`     | Absolute Indexed, X       | `$3D`   | 3     | 4 |\n`AND long, X`     | Absolute Long Indexed, X  | `$3F`   | 4     | 5 |\n`AND addr, Y`     | Absolute Indexed, Y       | `$39`   | 3     | 4 |\n`AND dp, X`       | Direct Page Indexed, X    | `$35`   | 2     | 4 |\n`AND (dp, X)`     | Direct Page Indirect, X   | `$21`   | 2     | 6 |\n`AND (dp), Y`     | DP Indirect Indexed, Y    | `$31`   | 2     | 5 |\n`AND [dp], Y`     | DP Indirect Long Indexed, Y | `$37` | 2     | 6 |\n`AND sr, S`       | Stack Relative            | `$23`   | 2     | 4 |\n`AND (sr, S), Y`  | SR Indirect Indexed, Y    | `$33`   | 2     | 7 |\n",
    "cpy": "CPY - Compare Index Register Y with Memory\n==========================================\n\n**Flags affected**: `n-----zc`\n\n`Y - M`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero (Set if `Y == M`)\n\n`c` ← Carry from ALU (Set if `Y >= M`)\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`CPY #const`      | Immediate                 | `$C0`   | 2 / 3 | 2 |\n`CPY addr`        | Absolute                  | `$CC`   | 3     | 4 |\n`CPY dp`          | Direct Page               | `$C4`   | 2     | 3 |\n",
    "dec": "DEC - Decrement\n===============\n\n**Flags affected**: `n-----z-`\n\n`M` ← `M - 1`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`DEC`             | Accumulator               | `$3A`   | 1     | 2\n`DEC addr`        | Absolute                  | `$CE`   | 3     | 6 |\n`DEC dp`          | Direct Page               | `$C6`   | 2     | 5 |\n`DEC addr, X`     | Absolute Indexed, X       | `$DE`   | 3     | 7 |\n`DEC dp, X`       | Direct Page Indexed, X    | `$D6`   | 2     | 6 |\n",
    "asl": "ASL - Arithmetic Shift Left\n===========================\n\n**Flags affected**: `n-----zc`\n\n`M` ← `M + M`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n`c` ← Most significant bit of original Memory\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`ASL`             | Accumulator               | `$0A`   | 1     | 2\n`ASL addr`        | Absolute                  | `$0E`   | 3     | 6 |\n`ASL dp`          | Direct Page               | `$06`   | 2     | 5 |\n`ASL addr, X`     | Absolute Indexed, X       | `$1E`   | 3     | 7 |\n`ASL dp, X`       | Direct Page Indexed, X    | `$16`   | 2     | 6 |\n",
    "pea": "PEA - Push Effective Absolute Address\n=====================================\n\n**Flags affected**: `--------`\n\n`S` ← `S - 2`\n`[S+2]` ← `addr.h`\n`[S+1]` ← `addr.l`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`PEA addr`        | Stack (Absolute)          | `$F4`   | 3     | 5\n",
    "bit": "BIT - Test Memory Bits against Accumulator\n==========================================\n\n**Flags affected**: `nv----z-`\n\n**Flags affected (Immediate addressing mode only)**: `------z-`\n\n`A & M`\n\n---\n`n` ← Most significant bit of memory\n\n`v` ← Second most significant bit of memory\n\n`z` ← Set if logical AND of memory and Accumulator is zero\n\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`BIT #const`      | Immediate                 | `$89`   | 2 / 3 | 2 |\n`BIT addr`        | Absolute                  | `$2C`   | 3     | 4 |\n`BIT dp`          | Direct Page               | `$24`   | 2     | 3 |\n`BIT addr, X`     | Absolute Indexed, X       | `$3C`   | 3     | 4 |\n`BIT dp, X`       | Direct Page Indexed, X    | `$34`   | 2     | 4 |\n",
    "rtl": "RTS, RTL - Return From Subroutine\n=================================\n\n**Flags affected**: `--------`\n\n**RTS:**\n`PC.l` ← `[S+1]`\n`PC.h` ← `[S+2]`\n`S` ← `S + 2`\n`PC` ← `PC + 1`\n\n**RTL:**\n`PC.l` ← `[S+1]`\n`PC.h` ← `[S+2]`\n`PBR` ← `[S+3]`\n`S` ← `S + 3`\n`PC` ← `PC + 1`\n\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`RTS`             | Stack (return)            | `$60`   | 1     | 6\n`RTL`             | Stack (return long)       | `$6B`   | 1     | 6\n",
    "rol": "ROL - Rotate Left\n=================\n\n**Flags affected**: `n-----zc`\n\n`M` ← `M + M + c`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n`c` ← Most significant bit of original Memory\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`ROL`             | Accumulator               | `$2A`   | 1     | 2\n`ROL addr`        | Absolute                  | `$2E`   | 3     | 6 |\n`ROL dp`          | Direct Page               | `$26`   | 2     | 5 |\n`ROL addr, X`     | Absolute Indexed, X       | `$3E`   | 3     | 7 |\n`ROL dp, X`       | Direct Page Indexed, X    | `$36`   | 2     | 6 |\n",
    "inc": "INC - Increment\n===============\n\n**Flags affected**: `n-----z-`\n\n`M` ← `M + 1`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`INC`             | Accumulator               | `$1A`   | 1     | 2\n`INC addr`        | Absolute                  | `$EE`   | 3     | 6 |\n`INC dp`          | Direct Page               | `$E6`   | 2     | 5 |\n`INC addr, X`     | Absolute Indexed, X       | `$FE`   | 3     | 7 |\n`INC dp, X`       | Direct Page Indexed, X    | `$F6`   | 2     | 6 |\n",
    "ror": "ROR - Rotate Right\n==================\n\n**Flags affected**: `n-----zc`\n\n`M` ← `(c << (m ? 7 : 15)) | (M >> 1)`\n\n---\n`n` ← Most significant bit of result\n\n`z` ← Set if the result is zero\n\n`c` ← Bit 0 of original memory\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`ROR`             | Accumulator               | `$6A`   | 1     | 2\n`ROR addr`        | Absolute                  | `$6E`   | 3     | 6 |\n`ROR dp`          | Direct Page               | `$66`   | 2     | 5 |\n`ROR addr, X`     | Absolute Indexed, X       | `$7E`   | 3     | 7 |\n`ROR dp, X`       | Direct Page Indexed, X    | `$76`   | 2     | 6 |\n",
    "stp": "STP - Stop the Processor\n========================\n\n**Flags affected**: `--------`\n\n`CPU clock enabled` ← `0`\n\nNote, this instruction can cause some builds of snes9x to freeze.\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`STP`             | Implied                   | `$DB`   | 1     | 3\n",
    "sty": "STY - Store Index Register Y to Memory\n======================================\n\n**Flags affected**: `--------`\n\n`M` ← `Y`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`STY addr`        | Absolute                  | `$8C`   | 3     | 4 |\n`STY dp`          | Direct Page               | `$84`   | 2     | 3 |\n`STY dp, X`       | Direct Page Indexed, X    | `$94`   | 2     | 4 |\n",
    "tyx": "Transfer Registers\n==================\n\n**Flags affected**: `n-----z-`\n\n**Flags affected (TCS, TXS)**: `--------`\n\n`Rd` ← `Rs`\n\n---\n`n` ← Most significant bit of the transferred value\n\n`z` ← Set if the transferred value is zero\n\nThe number of bits transferred depends on the state of the m, x and e flags:\n\n * Accumulator to Index:\n    * 8 bit Index (x=1): 8 bits transferred\n    * 16 bit Index (x=0): 16 bits transferred, no matter the state of m\n * Accumulator to/from Direct page register (D): 16 bits transferred\n * Index to Accumulator:\n    * 8 bit A (m=1): 8 bits transferred\n    * 16 bit A (m=0): 16 bits transferred (when x=1 (8 bit index), the high byte is 0)\n * Stack Pointer to X:\n    * 8 bit Index (x=1): 8 bits transferred, high byte of X = 0\n    * 16 bit Index (x=0): 16 bits transferred\n * Stack Pointer to Accumulator: 16 bits transferred\n * A/X to Stack Pointer:\n    * Native mode: 16 bits transferred\n    * Emulation mode: 8 bits transferred, high byte of S = 1\n\n---\nSyntax          | Name                      | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`TAX`             | Transfer A to X           | `$AA`   | 1     | 2\n`TAY`             | Transfer A to Y           | `$A8`   | 1     | 2\n`TCD`             | Transfer 16 bit A to D    | `$5B`   | 1     | 2\n`TCS`             | Transfer 16 bit A to S    | `$1B`   | 1     | 2\n`TDC`             | Transfer D to 16 bit A    | `$7B`   | 1     | 2\n`TSC`             | Transfer S to 16 bit A    | `$3B`   | 1     | 2\n`TSX`             | Transfer S to X           | `$BA`   | 1     | 2\n`TXA`             | Transfer X to A           | `$8A`   | 1     | 2\n`TXS`             | Transfer X to S           | `$9A`   | 1     | 2\n`TXY`             | Transfer X to Y           | `$9B`   | 1     | 2\n`TYA`             | Transfer Y to A           | `$98`   | 1     | 2\n`TYX`             | Transfer Y to X           | `$BB`   | 1     | 2\n",
    "per": "PER - Push Effective PC Relative Indirect Address\n=================================================\n\n**Flags affected**: `--------`\n\n`S` ← `S - 2`\n`T` ← `PC + Label`\n`[S+2]` ← `T.h`\n`[S+1]` ← `T.l`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`PER label`       | Stack (PC Relative Long)  | `$62`   | 3     | 6\n",
    "ldy": "LDY - Load Index Register Y from Memory\n=======================================\n\n**Flags affected**: `n-----z-`\n\n`Y` ← `M`\n\n---\n`n` ← Most significant bit of Y\n\n`z` ← Set if the Y is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`LDY #const`      | Immediate                 | `$A0`   | 2 / 3 | 2 |\n`LDY addr`        | Absolute                  | `$AC`   | 3     | 4 |\n`LDY dp`          | Direct Page               | `$A4`   | 2     | 3 |\n`LDY addr, X`     | Absolute Indexed, X       | `$BC`   | 3     | 4 |\n`LDY dp, X`       | Direct Page Indexed, X    | `$B4`   | 2     | 4 |\n",
    "pei": "PEI - Push Effective Indirect Address\n=====================================\n\n**Flags affected**: `--------`\n\n`S` ← `S - 2`\n`[S+2]` ← `[0:D+dp+1]`\n`[S+1]` ← `[0:D+dp]`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`PEI (dp)`        | Stack (DP Indirect)       | `$D4`   | 2     | 6 |\n",
    "sbc": "SBC - Subtract with Borrow from Accumulator\n===========================================\n\n**Flags affected**: `nv----zc`\n\n`A` ← `A + (~M) + c`\n\n\n`n` ← Most significant bit of result\n\n`v` ← Signed overflow of result\n\n`z` ← Set if the Accumulator is zero\n\n`c` ← Carry from ALU (bit 8/16 of result) (set if borrow not required)\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`SBC #const`      | Immediate                 | `$E9`   | 2 / 3 | 2 |\n`SBC addr`        | Absolute                  | `$ED`   | 3     | 4 |\n`SBC long`        | Absolute Long             | `$EF`   | 4     | 5 |\n`SBC dp`          | Direct Page               | `$E5`   | 2     | 3 |\n`SBC (dp)`        | Direct Page Indirect      | `$F2`   | 2     | 5 |\n`SBC [dp]`        | Direct Page Indirect Long | `$E7`   | 2     | 6 |\n`SBC addr, X`     | Absolute Indexed, X       | `$FD`   | 3     | 4 |\n`SBC long, X`     | Absolute Long Indexed, X  | `$FF`   | 4     | 5 |\n`SBC addr, Y`     | Absolute Indexed, Y       | `$F9`   | 3     | 4 |\n`SBC dp, X`       | Direct Page Indexed, X    | `$F5`   | 2     | 4 |\n`SBC (dp, X)`     | Direct Page Indirect, X   | `$E1`   | 2     | 6 |\n`SBC (dp), Y`     | DP Indirect Indexed, Y    | `$F1`   | 2     | 5 |\n`SBC [dp], Y`     | DP Indirect Long Indexed, Y | `$F7` | 2     | 6 |\n`SBC sr, S`       | Stack Relative            | `$E3`   | 2     | 4 |\n`SBC (sr, S), Y`  | SR Indirect Indexed, Y    | `$F3`   | 2     | 7 |\n",
    "cop": "Software Interrupts\n===================\n\n**Flags affected**: `----di--`\n\n**Native Mode:**\n\n`S` ← `S - 4`\n\n`[S+4]` ← `PBR`\n\n`[S+3]` ← `PC.h`\n\n`[S+2]` ← `PC.l`\n\n`[S+1]` ← `P`\n\n\n`d` ← `0`\n\n`i` ← `1`\n\n\n`PBR` ← `0`\n\n`PC` ← interrupt address\n\n\n**Emulation Mode:**\n\n`S` ← `S - 3`\n\n`[S+3]` ← `PC.h`\n\n`[S+2]` ← `PC.l`\n\n`[S+1]` ← `P`\n\n\n`d` ← `0`\n\n`i` ← `1`\n\n\n`PBR` ← `0`\n\n`PC` ← interrupt address\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`BRK param`       | Interrupt                 | `$00`   | 2     | 7 |\n`COP param`       | Interrupt                 | `$02`   | 2     | 7 |\n",
    "jml": "JMP, JML - Jump\n===============\n\n**Flags affected**: `--------`\n\n**JMP:**\n`PC` ← `M`\n\n**JML:**\n`PBR:PC` ← `M`\n\n\n\n\nNOTES:\n\n * The `JMP (addr)` instruction will always read the new program counter from Bank 0 (ie, `JMP ($8888)` will read 2 bytes from `$00:8888`).\n * The `JML [addr]` instruction will always read the new program counter from Bank 0 (ie, `JML [$9999]` will read 3 bytes from `$00:9999`).\n * The `JMP (addr, X)` instruction will read the new program counter from the Program Bank (`PBR`) (ie, `JMP ($AAAA, X)` will read 2 bytes from `PBR:{$AAAA + X}`).\n",
    "phy": "Push to Stack\n=============\n\n**Flags affected**: `--------`\n\n**8 bit register:**\n\n`S` ← `S - 1`\n\n`[S+1]` ← `R`\n\n---\n**16 bit register:**\n\n`S` ← `S - 2`\n\n`[S+2]` ← `R.h`\n\n`[S+1]` ← `R.l`\n\n---\nSyntax          | Name                      | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`PHA`             | Push Accumulator          | `$48`   | 1     | 3 |\n`PHB`             | Push Data Bank            | `$8B`   | 1     | 3 |\n`PHD`             | Push Direct Page Register | `$0B`   | 1     | 4 |\n`PHK`             | Push Program Bank Register| `$4B`   | 1     | 3 |\n`PHP`             | Push Processor Status Register| `$08`| 1     | 3 |\n`PHX`             | Push Index Register X     | `$DA`   | 1     | 3 |\n`PHY`             | Push Index Register Y     | `$5A`   | 1     | 3 |\n",
    "ply": "Pull from Stack\n================\n\n**Flags affected**: `n-----z-`\n\n**Flags affected (`PLP`)**: `nvmxdizc`\n\n**8 bit register:**\n`R` ← `[S+1]`\n`S` ← `S + 1`\n\n---\n`n` ← Most significant bit of register\n`z` ← Set if the register is zero\n\n---\n**16 bit register:**\n`R.l` ← `[S+1]`\n`R.h` ← `[S+2]`\n`S` ← `S + 2`\n\n---\n`n` ← Most significant bit of register\n`z` ← Set if the register is zero\n\n---\n**PLP (Native Mode):**\n`P` ← `[S+1]`\n`S` ← `S + 1`\n\n---\n**PLP (Emulation Mode):**\n`P` ← `[S+1]`\n`S` ← `S + 1`\n`x` ← `1`\n`m` ← `1`\n\nNote about PLP: If bit 4 (x) of the status register is set, then the high\nbyte of the index registers will be set to 0.\n\n---\nSyntax          | Name                      | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`PLA`             | Pull Accumulator          | `$68`   | 1     | 4 |\n`PLB`             | Pull Data Bank            | `$AB`   | 1     | 4\n`PLD`             | Pull Direct Page Register | `$2B`   | 1     | 5\n`PLP`             | Pull Processor Status Register| `$28`| 1     | 4\n`PLX`             | Pull Index Register X     | `$FA`   | 1     | 4 |\n`PLY`             | Pull Index Register Y     | `$7A`   | 1     | 4 |\n",
    "sta": "STA - Store Accumulator to Memory\n=================================\n\n**Flags affected**: `--------`\n\n`M` ← `A`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`STA addr`        | Absolute                  | `$8D`   | 3     | 4 |\n`STA long`        | Absolute Long             | `$8F`   | 4     | 5 |\n`STA dp`          | Direct Page               | `$85`   | 2     | 3 |\n`STA (dp)`        | Direct Page Indirect      | `$92`   | 2     | 5 |\n`STA [dp]`        | Direct Page Indirect Long | `$87`   | 2     | 6 |\n`STA addr, X`     | Absolute Indexed, X       | `$9D`   | 3     | 5 |\n`STA long, X`     | Absolute Long Indexed, X  | `$9F`   | 4     | 5 |\n`STA addr, Y`     | Absolute Indexed, Y       | `$99`   | 3     | 5 |\n`STA dp, X`       | Direct Page Indexed, X    | `$95`   | 2     | 4 |\n`STA (dp, X)`     | Direct Page Indirect, X   | `$81`   | 2     | 6 |\n`STA (dp), Y`     | DP Indirect Indexed, Y    | `$91`   | 2     | 6 |\n`STA [dp], Y`     | DP Indirect Long Indexed, Y | `$97` | 2     | 6 |\n`STA sr, S`       | Stack Relative            | `$83`   | 2     | 4 |\n`STA (sr, S), Y`  | SR Indirect Indexed, Y    | `$93`   | 2     | 7 |\n",
    "stx": "STX - Store Index Register X to Memory\n======================================\n\n**Flags affected**: `--------`\n\n`M` ← `X`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`STX addr`        | Absolute                  | `$8E`   | 3     | 4 |\n`STX dp`          | Direct Page               | `$86`   | 2     | 3 |\n`STX dp, Y`       | Direct Page Indexed, Y    | `$96`   | 2     | 4 |\n",
    "stz": "STZ - Store Zero to Memory\n==========================\n\n**Flags affected**: `--------`\n\n`M` ← `0`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`STZ addr`        | Absolute                  | `$9C`   | 3     | 4 |\n`STZ dp`          | Direct Page               | `$64`   | 2     | 3 |\n`STZ addr, X`     | Absolute Indexed, X       | `$9E`   | 3     | 5 |\n`STZ dp, X`       | Direct Page Indexed, X    | `$74`   | 2     | 4 |\n",
    "mvn": "MVN - Block Move Next\n=====================\n\nThis instruction is also known as **Block Move Negative**.\n\n**Flags affected**: `--------`\n\n**Parameters:**\n\n`X`: source address\n\n`Y`: destination address\n\n`C`: length - 1\n\n`DBR` ← `destBank`\n\n`repeat:`\n\n`T` ← `srcBank:X`\n\n`DBR:Y` ← `T`\n\n`X` ← `X + 1`\n\n`Y` ← `Y + 1`\n\n`C` ← `C - 1`\n\n`until C == 0xffff`\n\nNOTES:\n\n * The number of bytes transferred is `C + 1`\n * After the transfer is complete:\n    * `DBR` = destination bank\n    * `C` = `0xFFFF`\n    * `X` = the byte after the end of the source block\n    * `Y` = the byte after the end of the destination block.\n * If bit 4 (x) of the status register is set, `MVN` will only be able\n   to access the first page of the source and destination banks.\n * Block move instructions can be interrupted.  The move will resume after the\n   <abbr title=\"Interrupt Service Routine\">ISR</abbr> returns, provided the\n   `C`, `X`, `Y` registers, Program Counter and `MVN` instruction are unchanged.\n * `MVN` should be used if the blocks do not overlap or if the destination address\n   is less than (more negative than) the source address.\n * `MVN` can be used to fill an array or memory block:\n\n        set value of first element\n\n        set X = array_start\n        set Y = array_start + element_size\n        set C = (array_count - 1) * element_size - 1\n\n        MVN array_bank array_bank\n\n---\nSyntax                | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------------|---------------------------|-------|-------|--------|\n`MVN srcBank, destBank` | Block Move                | `$54`   | 3     |  | 7 per byte moved\n",
    "tsb": "TSB - Test and Set Memory Bits Against Accumulator\n==================================================\n\n**Flags affected**: `------z-`\n\n`z` ← Set if logical AND of memory and Accumulator is zero\n\n---\n`M` ← `M | A`\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`TSB addr`        | Absolute                  | `$0C`   | 3     | 6 |\n`TSB dp`          | Direct Page               | `$04`   | 2     | 5 |\n",
    "xba": "XBA - Exchange the B and A Accumulators\n=======================================\n\n**Flags affected**: `n-----z-`\n\n`T` ← `Ah`\n\n`Ah` ← `Al`\n\n`Al` ← `T`\n\n\n`n` ← Value of bit 7 of the new Accumulator (even in 16 bit mode)\n`z` ← Set if bits 0-7 of the new Accumulator are 0 (even in 16 bit mode)\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`XBA`             | Implied                   | `$EB`   | 1     | 3\n",
    "lda": "LDA - Load Accumulator from Memory\n==================================\n\n**Flags affected**: `n-----z-`\n\n`A` ← `M`\n\n---\n`n` ← Most significant bit of Accumulator\n\n`z` ← Set if the Accumulator is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`LDA #const`      | Immediate                 | `$A9`   | 2 / 3 | 2 |\n`LDA addr`        | Absolute                  | `$AD`   | 3     | 4 |\n`LDA long`        | Absolute Long             | `$AF`   | 4     | 5 |\n`LDA dp`          | Direct Page               | `$A5`   | 2     | 3 |\n`LDA (dp)`        | Direct Page Indirect      | `$B2`   | 2     | 5 |\n`LDA [dp]`        | Direct Page Indirect Long | `$A7`   | 2     | 6 |\n`LDA addr, X`     | Absolute Indexed, X       | `$BD`   | 3     | 4 |\n`LDA long, X`     | Absolute Long Indexed, X  | `$BF`   | 4     | 5 |\n`LDA addr, Y`     | Absolute Indexed, Y       | `$B9`   | 3     | 4 |\n`LDA dp, X`       | Direct Page Indexed, X    | `$B5`   | 2     | 4 |\n`LDA (dp, X)`     | Direct Page Indirect, X   | `$A1`   | 2     | 6 |\n`LDA (dp), Y`     | DP Indirect Indexed, Y    | `$B1`   | 2     | 5 |\n`LDA [dp], Y`     | DP Indirect Long Indexed, Y | `$B7` | 2     | 6 |\n`LDA sr, S`       | Stack Relative            | `$A3`   | 2     | 4 |\n`LDA (sr, S), Y`  | SR Indirect Indexed, Y    | `$B3`   | 2     | 7 |\n",
    "ldx": "LDX - Load Index Register X from Memory\n=======================================\n\n**Flags affected**: `n-----z-`\n\n`X` ← `M`\n\n---\n`n` ← Most significant bit of X\n\n`z` ← Set if the X is zero\n\n---\nSyntax          | Addressing Mode           | Opcode| Bytes | Cycles |\n----------------|---------------------------|-------|-------|--------|\n`LDX #const`      | Immediate                 | `$A2`   | 2 / 3 | 2 |\n`LDX addr`        | Absolute                  | `$AE`   | 3     | 4 |\n`LDX dp`          | Direct Page               | `$A6`   | 2     | 3 |\n`LDX addr, Y`     | Absolute Indexed, Y       | `$BE`   | 3     | 4 |\n`LDX dp, Y`       | Direct Page Indexed, Y    | `$B6`   | 2     | 4 |\n"
  },
  "keys_with_shared_doc": {
    "pla": "ply",
    "tay": "tyx",
    "php": "phy",
    "tsx": "tyx",
    "bpl": "brl",
    "tsc": "tyx",
    "txa": "tyx",
    "rts": "rtl",
    "txy": "tyx",
    "tya": "tyx",
    "plx": "ply",
    "tax": "tyx",
    "pha": "phy",
    "jmp": "jml",
    "bra": "brl",
    "bcc": "brl",
    "bne": "brl",
    "tcd": "tyx",
    "bvc": "brl",
    "dex": "dey",
    "phd": "phy",
    "tcs": "tyx",
    "pld": "ply",
    "cli": "clv",
    "tdc": "tyx",
    "plb": "ply",
    "cld": "clv",
    "clc": "clv",
    "bvs": "brl",
    "inx": "iny",
    "bmi": "brl",
    "phx": "phy",
    "beq": "brl",
    "plp": "ply",
    "jsr": "jsl",
    "bcs": "brl",
    "phk": "phy",
    "sec": "sei",
    "sed": "sei",
    "txs": "tyx",
    "brk": "cop",
    "phb": "phy"
  }
}