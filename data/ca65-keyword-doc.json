{
  "keys_to_doc": {
    "forceimport": {
      "documentation": "`.FORCEIMPORT`\n---\nImport an absolute symbol from another module. The command is followed by a\ncomma separated list of symbols to import. The command is similar to [`.IMPORT`](https://cc65.github.io/doc/ca65.html#.IMPORT), but the import reference is always\nwritten to the generated object file, even if the symbol is never referenced\n([`.IMPORT`](https://cc65.github.io/doc/ca65.html#.IMPORT) will not generate import\nreferences for unused symbols).\n\nExample:\n\n\n```ca65\n  .forceimport    needthisone, needthistoo\n  \n```\n\n\n\nSee: [`.IMPORT`](https://cc65.github.io/doc/ca65.html#.IMPORT)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "reloc": {
      "documentation": "`.RELOC`\n---\nSwitch back to relocatable mode. See the [`.ORG`](https://cc65.github.io/doc/ca65.html#.ORG) command.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "elseif": {
      "documentation": "`.ELSEIF`\n---\nConditional assembly: Reverse current condition and test a new one.\n\n",
      "snippet_type": "ca65_else_if"
    },
    "right": {
      "documentation": "`.RIGHT`\n---\nBuiltin function. Extracts the right part of a given token list.\n\nSyntax:\n\n\n```ca65\n  .RIGHT (<int expr>, <token list>)\n  \n```\n\n\n\nThe first integer expression gives the number of tokens to extract from the\ntoken list. The second argument is the token list itself.  The token list\nmay optionally be enclosed into curly braces. This allows the inclusion of\ntokens that would otherwise terminate the list (the closing right paren in\nthe given case).\n\nSee also the [`.LEFT`](https://cc65.github.io/doc/ca65.html#.LEFT) and [`.MID`](https://cc65.github.io/doc/ca65.html#.MID) builtin functions.\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "a8": {
      "documentation": "`.A8`\n---\nValid only in 65816 mode. Assume the accumulator is 8 bit.\n\nNote: This command will not emit any code, it will tell the assembler to\ncreate 8 bit operands for immediate accu addressing mode.\n\nSee also: [`.SMART`](https://cc65.github.io/doc/ca65.html#.SMART)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "enum": {
      "documentation": "`.ENUM`\n---\nStart an enumeration. This directive is very similar to the C `enum`\nkeyword. If a name is given, a new scope is created for the enumeration,\notherwise the enumeration members are placed in the enclosing scope.\n\nIn the enumeration body, symbols are declared. The first symbol has a value\nof zero, and each following symbol will get the value of the preceding, plus\none. That behaviour may be overridden by an explicit assignment. Two symbols\nmay have the same value.\n\nExample:\n\n\n```ca65\n  .enum   errorcodes\n          no_error\n          file_error\n          parse_error\n  .endenum\n  \n```\n\n\n\nThe above example will create a new scope named `errorcodes` with three\nsymbols in it that get the values 0, 1, and 2 respectively. Another way\nto write that would have been:\n\n\n```ca65\n  .scope  errorcodes\n          no_error        = 0\n          file_error      = 1\n          parse_error     = 2\n  .endscope\n  \n```\n\n\n\nPlease note that explicit scoping must be used to access the identifiers:\n\n\n```ca65\n  .word   errorcodes::no_error\n  \n```\n\n\n\nA more complex example:\n\n\n```ca65\n  .enum\n          EUNKNOWN        = -1\n          EOK\n          EFILE\n          EBUSY\n          EAGAIN\n          EWOULDBLOCK     = EAGAIN\n  .endenum\n  \n```\n\n\n\nIn that example, the enumeration does not have a name, which means that the\nmembers will be visible in the enclosing scope, and can be used in that scope\nwithout explicit scoping. The first member (`EUNKNOWN`) has the value -1.\nThe values for the following members are incremented by one; so, `EOK`\nwould be zero, and so on. `EWOULDBLOCK` is an alias for `EAGAIN`; so,\nit has an override for the value, using an already defined symbol.\n\n",
      "snippet_type": "ca65_keyword_block"
    },
    "localchar": {
      "documentation": "`.LOCALCHAR`\n---\nDefines the character that start \"cheap\" local labels. You may use one\nof '@' and '?' as start character. The default is '@'.\n\nCheap local labels are labels that are visible only between two non\ncheap labels. This way you can reuse identifiers like \"`loop`\" without\nusing explicit lexical nesting.\n\nExample:\n\n\n```ca65\n  .localchar      '?'\n\n  Clear:  lda     #$00            ; Global label\n  ?Loop:  sta     Mem,y           ; Local label\n          dey\n          bne     ?Loop           ; Ok\n          rts\n  Sub:    ...                     ; New global label\n          bne     ?Loop           ; ERROR: Unknown identifier!\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_char"
    },
    "ifnref": {
      "documentation": "`.IFNREF`\n---\nConditional assembly: Check if a symbol is referenced. Must be followed\nby a symbol name. The condition is true if the given symbol was\nnot referenced before, and false otherwise.\n\nSee also: [`.REFERENCED`](https://cc65.github.io/doc/ca65.html#.REFERENCED)\n\n",
      "snippet_type": "ca65_if_param"
    },
    "ifblank": {
      "documentation": "`.IFBLANK`\n---\nConditional assembly: Check if there are any remaining tokens in this line,\nand evaluate to FALSE if this is the case, and to TRUE otherwise. If the\ncondition is not true, further lines are not assembled until an [`.ELSE`](https://cc65.github.io/doc/ca65.html#.ELSE), [`.ELSEIF`](https://cc65.github.io/doc/ca65.html#.ELSEIF) or\n[`.ENDIF`](https://cc65.github.io/doc/ca65.html#.ENDIF) directive.\n\nThis command is often used to check if a macro parameter was given. Since an\nempty macro parameter will evaluate to nothing, the condition will evaluate\nto TRUE if an empty parameter was given.\n\nExample:\n\n\n```ca65\n  .macro     arg1, arg2\n  .ifblank   arg2\n             lda     #arg1\n  .else\n             lda     #arg2\n  .endif\n  .endmacro\n  \n```\n\n\n\nSee also: [`.BLANK`](https://cc65.github.io/doc/ca65.html#.BLANK)\n\n",
      "snippet_type": "ca65_if_param"
    },
    "delmacro": {
      "documentation": "`.DELMAC, .DELMACRO`\n---\nDelete a classic macro (defined with [`.MACRO`](https://cc65.github.io/doc/ca65.html#.MACRO)) . The command is followed by the name of an\nexisting macro. Its definition will be deleted together with the name.\nIf necessary, another macro with this name may be defined later.\n\nSee: [`.ENDMACRO`](https://cc65.github.io/doc/ca65.html#.ENDMACRO),\n[`.EXITMACRO`](https://cc65.github.io/doc/ca65.html#.EXITMACRO),\n[`.MACRO`](https://cc65.github.io/doc/ca65.html#.MACRO)\n\nSee also section \n[Macros](https://cc65.github.io/doc/ca65.html#macros).\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "dbyt": {
      "documentation": "`.DBYT`\n---\nDefine word sized data with the hi and lo bytes swapped (use `.WORD` to\ncreate word sized data in native 65XX format). Must be followed by a\nsequence of (word ranged) expressions.\n\nExample:\n\n\n```ca65\n  .dbyt   $1234, $4512\n  \n```\n\n\n\nThis will emit the bytes\n\n\n```ca65\n  $12 $34 $45 $12\n  \n```\n\n\n\ninto the current segment in that order.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "endrepeat": {
      "documentation": "`.ENDREP, .ENDREPEAT`\n---\nEnd a [`.REPEAT`](https://cc65.github.io/doc/ca65.html#.REPEAT) block.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "addrsize": {
      "documentation": "`.ADDRSIZE`\n---\nThe `.ADDRSIZE` function is used to return the internal address size\nassociated with a symbol. This can be helpful in macros when knowing the address\nsize of a symbol can help with custom instructions.\n\nExample:\n\n\n```ca65\n  .macro myLDA foo\n          .if .ADDRSIZE(foo) = 1\n                  ;do custom command based on zeropage addressing:\n                  .byte 0A5h, foo\n          .elseif .ADDRSIZE(foo) = 2\n                  ;do custom command based on absolute addressing:\n                  .byte 0ADh\n                  .word foo\n          .elseif .ADDRSIZE(foo) = 0\n                  ; no address size defined for this symbol:\n                  .out .sprintf(\"Error, address size unknown for symbol %s\", .string(foo))\n          .endif\n  .endmacro\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "listbytes": {
      "documentation": "`.LISTBYTES`\n---\nSet, how many bytes are shown in the listing for one source line. The\ndefault is 12, so the listing will show only the first 12 bytes for any\nsource line that generates more than 12 bytes of code or data.\nThe directive needs an argument, which is either \"unlimited\", or an\ninteger constant in the range 4..255.\n\nExamples:\n\n\n```ca65\n  .listbytes      unlimited       ; List all bytes\n  .listbytes      12              ; List the first 12 bytes\n  .incbin         \"data.bin\"      ; Include large binary file\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "debuginfo": {
      "documentation": "`.DEBUGINFO`\n---\nSwitch on or off debug info generation. The default is off (that is,\nthe object file will not contain debug infos), but may be changed by the\n-g switch on the command line.\nThe command can be followed by a '+' or '-' character to switch the\noption on or off respectively.\n\nExample:\n\n\n```ca65\n  .debuginfo      +       ; Generate debug info\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "p02": {
      "documentation": "`.P02`\n---\nEnable the 6502 instruction set, disable 65SC02, 65C02 and 65816\ninstructions. This is the default if not overridden by the\n[`--cpu`](https://cc65.github.io/doc/ca65.html#option--cpu) command line option.\n\nSee: [`.PC02`](https://cc65.github.io/doc/ca65.html#.PC02), [`.PSC02`](https://cc65.github.io/doc/ca65.html#.PSC02), [`.P816`](https://cc65.github.io/doc/ca65.html#.P816) and\n[`.P4510`](https://cc65.github.io/doc/ca65.html#.P4510)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "popcharmap": {
      "documentation": "`.POPCHARMAP`\n---\nPop the last character mapping from the stack, and activate it.\n\nThis command will switch back to the character mapping that was last pushed onto the\ncharacter mapping stack using the [`.PUSHCHARMAP`](https://cc65.github.io/doc/ca65.html#.PUSHCHARMAP)\ncommand, and remove this entry from the stack.\n\nThe assembler will print an error message if the mappting stack is empty when\nthis command is issued.\n\nSee: [`.CHARMAP`](https://cc65.github.io/doc/ca65.html#.CHARMAP), [`.PUSHCHARMAP`](https://cc65.github.io/doc/ca65.html#.PUSHCHARMAP)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "importzp": {
      "documentation": "`.IMPORTZP`\n---\nImport a symbol from another module. The command is followed by a comma\nseparated list of symbols to import. The symbols are explicitly imported\nas zero page symbols (that is, symbols with values in byte range).\n\nExample:\n\n\n```ca65\n  .importzp       foo, bar\n  \n```\n\n\n\nSee: [`.IMPORT`](https://cc65.github.io/doc/ca65.html#.IMPORT)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "sizeof": {
      "documentation": "`.SIZEOF`\n---\n`.SIZEOF()` is a pseudo function that returns the size of its argument.\nThe argument can be a struct/union, a struct member, a scope/procedure, or a\nlabel. In the case of a procedure or label, its size is defined by the\namount of data placed in the segment where the label is relative to. If a\nline of code switches segments (for example, in a macro), data placed in\nother segments does not count for the size.\n\nPlease note that a symbol or scope must exist before it can be used together\nwith `.SIZEOF()` (that may get relaxed later, but always will be true for\nscopes). A scope has preference over a symbol with the same name; so, if the\nlast part of a name represents both a scope and a symbol, then the scope is\nchosen over the symbol.\n\nAfter the following code:\n\n\n```ca65\n  .struct Point                   ; Struct size = 4\n          xcoord  .word\n          ycoord  .word\n  .endstruct\n\n  P:      .tag    Point           ; Declare a point\n  @P:     .tag    Point           ; Declare another point\n\n  .code\n  .proc   Code\n          nop\n          .proc   Inner\n                  nop\n          .endproc\n          nop\n  .endproc\n\n  .proc   Data\n  .data                           ; Segment switch!!!\n          .res    4\n  .endproc\n  \n```\n\n\n\n\n\n### `.sizeof(Point)`\n\nwill have the value 4, because this is the size of struct `Point`.\n\n\n### `.sizeof(Point::xcoord)`\n\nwill have the value 2, because this is the size of the member `xcoord`\nin struct `Point`.\n\n\n### `.sizeof(P)`\n\nwill have the value 4, this is the size of the data declared on the same\nsource line as the label `P`, which is in the same segment that `P`\nis relative to.\n\n\n### `.sizeof(@P)`\n\nwill have the value 4, see above. The example demonstrates that `.SIZEOF`\ndoes also work for cheap local symbols.\n\n\n### `.sizeof(Code)`\n\nwill have the value 3, since this is amount of data emitted into the code\nsegment, the segment that was active when `Code` was entered. Note that\nthis value includes the amount of data emitted in child scopes (in this\ncase `Code::Inner`).\n\n\n### `.sizeof(Code::Inner)`\n\nwill have the value 1 as expected.\n\n\n### `.sizeof(Data)`\n\nwill have the value 0. Data is emitted within the scope `Data`, but since\nthe segment is switched after entry, this data is emitted into another\nsegment.\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "ifp816": {
      "documentation": "`.IFP816`\n---\nConditional assembly: Check if the assembler is currently in 65816 mode\n(see [`.P816`](https://cc65.github.io/doc/ca65.html#.P816) command).\n\n",
      "snippet_type": "ca65_if_no_param"
    },
    "repeat": {
      "documentation": "`.REPEAT`\n---\nRepeat all commands between `.REPEAT` and [`.ENDREPEAT`](https://cc65.github.io/doc/ca65.html#.ENDREPEAT) constant number of times. The command is followed by\na constant expression that tells how many times the commands in the body\nshould get repeated. Optionally, a comma and an identifier may be specified.\nIf this identifier is found in the body of the repeat statement, it is\nreplaced by the current repeat count (starting with zero for the first time\nthe body is repeated).\n\n`.REPEAT` statements may be nested. If you use the same repeat count\nidentifier for a nested `.REPEAT` statement, the one from the inner\nlevel will be used, not the one from the outer level.\n\nExample:\n\nThe following macro will emit a string that is \"encrypted\" in that all\ncharacters of the string are XORed by the value $55.\n\n\n```ca65\n  .macro  Crypt   Arg\n          .repeat .strlen(Arg), I\n          .byte   .strat(Arg, I) ^ $55\n          .endrep\n  .endmacro\n  \n```\n\n\n\nSee: [`.ENDREPEAT`](https://cc65.github.io/doc/ca65.html#.ENDREPEAT)\n\n",
      "snippet_type": "ca65_keyword_block"
    },
    "paramcount": {
      "documentation": "`.PARAMCOUNT`\n---\nThis builtin pseudo variable is only available in macros. It is replaced by\nthe actual number of parameters that were given in the macro invocation.\n\nExample:\n\n\n```ca65\n  .macro  foo     arg1, arg2, arg3\n  .if     .paramcount <> 3\n  .error  \"Too few parameters for macro foo\"\n  .endif\n  ...\n  .endmacro\n  \n```\n\n\n\nSee section \n[Macros](https://cc65.github.io/doc/ca65.html#macros).\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "p4510": {
      "documentation": "`.P4510`\n---\nEnable the 4510 instruction set. This is a superset of the 65C02 and\n6502 instruction sets.\n\nSee: [`.P02`](https://cc65.github.io/doc/ca65.html#.P02), [`.PSC02`](https://cc65.github.io/doc/ca65.html#.PSC02), [`.PC02`](https://cc65.github.io/doc/ca65.html#.PC02) and\n[`.P816`](https://cc65.github.io/doc/ca65.html#.P816)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "word": {
      "documentation": "`.WORD`\n---\nDefine word sized data. Must be followed by a sequence of (word ranged,\nbut not necessarily constant) expressions.\n\nExample:\n\n\n```ca65\n  .word   $0D00, $AF13, _Clear\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "ifp4510": {
      "documentation": "`.IFP4510`\n---\nConditional assembly: Check if the assembler is currently in 4510 mode\n(see [`.P4510`](https://cc65.github.io/doc/ca65.html#.P4510) command).\n\n",
      "snippet_type": "ca65_if_no_param"
    },
    "res": {
      "documentation": "`.RES`\n---\nReserve storage. The command is followed by one or two constant\nexpressions. The first one is mandatory and defines, how many bytes of\nstorage should be defined. The second, optional expression must be a\nconstant byte value that will be used as value of the data. If there\nis no fill value given, the linker will use the value defined in the\nlinker configuration file (default: zero).\n\nExample:\n\n\n```ca65\n  ; Reserve 12 bytes of memory with value $AA\n  .res    12, $AA\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "bank": {
      "documentation": "\n---\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "macpack": {
      "documentation": "`.MACPACK`\n---\nInsert a predefined macro package. The command is followed by an\nidentifier specifying the macro package to insert. Available macro\npackages are:\n\n\n```ca65\n  atari           Defines the scrcode macro.\n  cbm             Defines the scrcode macro.\n  cpu             Defines constants for the .CPU variable.\n  generic         Defines generic macros like add, sub, and blt.\n  longbranch      Defines conditional long-jump macros.\n  \n```\n\n\n\nIncluding a macro package twice, or including a macro package that\nredefines already existing macros will lead to an error.\n\nExample:\n\n\n```ca65\n  .macpack        longbranch      ; Include macro package\n\n          cmp     #$20            ; Set condition codes\n          jne     Label           ; Jump long on condition\n  \n```\n\n\n\nMacro packages are explained in more detail in section \n[Macro packages](https://cc65.github.io/doc/ca65.html#macropackages).\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "left": {
      "documentation": "`.LEFT`\n---\nBuiltin function. Extracts the left part of a given token list.\n\nSyntax:\n\n\n```ca65\n  .LEFT (<int expr>, <token list>)\n  \n```\n\n\n\nThe first integer expression gives the number of tokens to extract from\nthe token list. The second argument is the token list itself. The token\nlist may optionally be enclosed into curly braces. This allows the\ninclusion of tokens that would otherwise terminate the list (the closing\nright paren in the given case).\n\nExample:\n\nTo check in a macro if the given argument has a '#' as first token\n(immediate addressing mode), use something like this:\n\n\n```ca65\n  .macro  ldax    arg\n          ...\n          .if (.match (.left (1, {arg}), #))\n\n          ; ldax called with immediate operand\n          ...\n\n          .endif\n          ...\n  .endmacro\n  \n```\n\n\n\nSee also the [`.MID`](https://cc65.github.io/doc/ca65.html#.MID) and [`.RIGHT`](https://cc65.github.io/doc/ca65.html#.RIGHT) builtin functions.\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "ident": {
      "documentation": "`.IDENT`\n---\nThe function expects a string as its argument, and converts this argument\ninto an identifier. If the string starts with the current [`.LOCALCHAR`](https://cc65.github.io/doc/ca65.html#.LOCALCHAR), it will be converted into a cheap local\nidentifier, otherwise it will be converted into a normal identifier.\n\nExample:\n\n\n```ca65\n  .macro  makelabel       arg1, arg2\n          .ident (.concat (arg1, arg2)):\n  .endmacro\n\n          makelabel       \"foo\", \"bar\"\n\n          .word           foobar          ; Valid label\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "referto": {
      "documentation": "`.REFERTO, .REFTO`\n---\nMark a symbol as referenced.\n\nIt is useful in combination with the [`.IFREF`](https://cc65.github.io/doc/ca65.html#.IFREF)\ncommand. A subroutine with two entry points can be created. When the first\nentry point is called, it sets some default value as an argument, and falls\nthrough into the second entry point. `.REFERTO` helps to ensure that\nthe second part is included into binary when only the first entry point is\nactually used from the code.\n\nExample:\n\n\n```ca65\n  .ifref NegateValue              ; If this subroutine is used\n  NegateValue:                    ; Define it\n          lda     #0\n          sec\n          sbc     Value\n      .ifref ResetValue           ; If the ResetValue is also used\n          jmp     SetValue        ; Jump over it\n      .else\n          .refto  SetValue        ; Ensure that SetValue will be included\n      .endif\n  .endif\n\n  .ifref ResetValue               ; If this subroutine is used\n  ResetValue:                     ; Define it\n          lda     #0              ; Set a default value\n          .refto  SetValue        ; Ensure that SetValue will be included\n  .endif\n\n  .ifref SetValue                 ; If this or previous subroutine is used\n  SetValue:\n          sta     Value\n          rts\n  .endif\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "addr": {
      "documentation": "`.ADDR`\n---\nDefine word sized data. In 6502 mode, this is an alias for `.WORD` and\nmay be used for better readability if the data words are address values. In\n65816 mode, the address is forced to be 16 bit wide to fit into the current\nsegment. See also [`.FARADDR`](https://cc65.github.io/doc/ca65.html#.FARADDR). The command\nmust be followed by a sequence of (not necessarily constant) expressions.\n\nExample:\n\n\n```ca65\n  .addr   $0D00, $AF13, _Clear\n  \n```\n\n\n\nSee: [`.FARADDR`](https://cc65.github.io/doc/ca65.html#.FARADDR), [`.WORD`](https://cc65.github.io/doc/ca65.html#.WORD)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "ifpc02": {
      "documentation": "`.IFPC02`\n---\nConditional assembly: Check if the assembler is currently in 65C02 mode\n(see [`.PC02`](https://cc65.github.io/doc/ca65.html#.PC02) command).\n\n",
      "snippet_type": "ca65_if_no_param"
    },
    "loword": {
      "documentation": "`.LOWORD`\n---\nThe function returns the low word (that is, bits 0-15) of its argument.\n\nSee: [`.HIWORD`](https://cc65.github.io/doc/ca65.html#.HIWORD)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "bankbyte": {
      "documentation": "`.BANKBYTE`\n---\nThe function returns the bank byte (that is, bits 16-23) of its argument.\nIt works identical to the '^' operator.\n\nSee: [`.HIBYTE`](https://cc65.github.io/doc/ca65.html#.HIBYTE),\n[`.LOBYTE`](https://cc65.github.io/doc/ca65.html#.LOBYTE)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "error": {
      "documentation": "`.ERROR`\n---\nForce an assembly error. The assembler will output an error message\npreceded by \"User error\". Assembly is continued but no object file will\ngenerated.\n\nThis command may be used to check for initial conditions that must be\nset before assembling a source file.\n\nExample:\n\n\n```ca65\n  .if     foo = 1\n  ...\n  .elseif bar = 1\n  ...\n  .else\n  .error  \"Must define foo or bar!\"\n  .endif\n  \n```\n\n\n\nSee also: [`.FATAL`](https://cc65.github.io/doc/ca65.html#.FATAL),\n[`.OUT`](https://cc65.github.io/doc/ca65.html#.OUT),\n[`.WARNING`](https://cc65.github.io/doc/ca65.html#.WARNING)\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "assert": {
      "documentation": "`.ASSERT`\n---\nAdd an assertion. The command is followed by an expression, an action\nspecifier, and an optional message that is output in case the assertion\nfails. If no message was given, the string \"Assertion failed\" is used. The\naction specifier may be one of `warning`, `error`, `ldwarning` or\n`lderror`. In the former two cases, the assertion is evaluated by the\nassembler if possible, and in any case, it's also passed to the linker in\nthe object file (if one is generated). The linker will then evaluate the\nexpression when segment placement has been done.\n\nExample:\n\n\n```ca65\n  .assert         * = $8000, error, \"Code not at $8000\"\n  \n```\n\n\n\nThe example assertion will check that the current location is at $8000,\nwhen the output file is written, and abort with an error if this is not\nthe case. More complex expressions are possible. The action specifier\n`warning` outputs a warning, while the `error` specifier outputs\nan error message. In the latter case, generation of the output file is\nsuppressed in both the assembler and linker.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "byte": {
      "documentation": "`.BYT, .BYTE`\n---\nDefine byte sized data. Must be followed by a sequence of (byte ranged)\nexpressions or strings. Strings will be translated using the current\ncharacter mapping definition.\n\nExample:\n\n\n```ca65\n  .byte   \"Hello \"\n  .byt    \"world\", $0D, $00\n  \n```\n\n\n\nSee: [`.ASCIIZ`](https://cc65.github.io/doc/ca65.html#.ASCIIZ),[`.CHARMAP`](https://cc65.github.io/doc/ca65.html#.CHARMAP)\n[`.LITERAL`](https://cc65.github.io/doc/ca65.html#.LITERAL)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "i16": {
      "documentation": "`.I16`\n---\nValid only in 65816 mode. Assume the index registers are 16 bit.\n\nNote: This command will not emit any code, it will tell the assembler to\ncreate 16 bit operands for immediate operands.\n\nSee also the [`.I8`](https://cc65.github.io/doc/ca65.html#.I8) and [`.SMART`](https://cc65.github.io/doc/ca65.html#.SMART) commands.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "interruptor": {
      "documentation": "`.INTERRUPTOR`\n---\nExport a symbol and mark it as an interruptor. This may be used together\nwith the linker to build a table of interruptor subroutines that are called\nin an interrupt.\n\nNote: The linker has a feature to build a table of marked routines, but it\nis your code that must call these routines, so just declaring a symbol as\ninterruptor does nothing by itself.\n\nAn interruptor is always exported as an absolute (16 bit) symbol. You don't\nneed to use an additional `.export` statement, this is implied by\n`.interruptor`. It may have an optional priority that is separated by a\ncomma. Higher numeric values mean a higher priority. If no priority is\ngiven, the default priority of 7 is used. Be careful when assigning\npriorities to your own module constructors so they won't interfere with the\nones in the cc65 library.\n\nExample:\n\n\n```ca65\n  .interruptor    IrqHandler\n  .interruptor    Handler, 16\n  \n```\n\n\n\nSee the [`.CONDES`](https://cc65.github.io/doc/ca65.html#.CONDES) command and the separate\nsection \n[Module constructors/destructors](https://cc65.github.io/doc/ca65.html#condes) explaining\nthe feature in more detail.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "pagelength": {
      "documentation": "`.PAGELEN, .PAGELENGTH`\n---\nSet the page length for the listing. Must be followed by an integer\nconstant. The value may be \"unlimited\", or in the range 32 to 127. The\nstatement has no effect if no listing is generated. The default value is -1\n(unlimited) but may be overridden by the `--pagelength` command line\noption. Beware: Since ca65 is a one pass assembler, the listing is generated\nafter assembly is complete, you cannot use multiple line lengths with one\nsource. Instead, the value set with the last `.PAGELENGTH` is used.\n\nExamples:\n\n\n```ca65\n  .pagelength     66              ; Use 66 lines per listing page\n\n  .pagelength     unlimited       ; Unlimited page length\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "blank": {
      "documentation": "`.BLANK`\n---\nBuiltin function. The function evaluates its argument in parentheses and yields\n\"false\" if the argument is non blank (there is an argument), and \"true\" if\nthere is no argument.  The token list that makes up the function argument\nmay optionally be enclosed in curly braces. This allows the inclusion of\ntokens that would otherwise terminate the list (the closing right\nparenthesis). The curly braces are not considered part of the list, a list\njust consisting of curly braces is considered to be empty.\n\nAs an example, the `.IFBLANK` statement may be replaced by\n\n\n```ca65\n  .if     .blank({arg})\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "case": {
      "documentation": "`.CASE`\n---\nSwitch on or off case sensitivity on identifiers. The default is off\n(that is, identifiers are case sensitive), but may be changed by the\n-i switch on the command line.\nThe command can be followed by a '+' or '-' character to switch the\noption on or off respectively.\n\nExample:\n\n\n```ca65\n  .case   -               ; Identifiers are not case sensitive\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "data": {
      "documentation": "`.DATA`\n---\nSwitch to the DATA segment. The name of the DATA segment is always\n\"DATA\", so this is a shortcut for\n\n\n```ca65\n  .segment  \"DATA\"\n  \n```\n\n\n\nSee also the [`.SEGMENT`](https://cc65.github.io/doc/ca65.html#.SEGMENT) command.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "import": {
      "documentation": "`.IMPORT`\n---\nImport a symbol from another module. The command is followed by a comma\nseparated list of symbols to import, with each one optionally followed by\nan address specification.\n\nExample:\n\n\n```ca65\n  .import foo\n  .import bar: zeropage\n  \n```\n\n\n\nSee: [`.IMPORTZP`](https://cc65.github.io/doc/ca65.html#.IMPORTZP)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "constructor": {
      "documentation": "`.CONSTRUCTOR`\n---\nExport a symbol and mark it as a module constructor. This may be used\ntogether with the linker to build a table of constructor subroutines that\nare called by the startup code.\n\nNote: The linker has a feature to build a table of marked routines, but it\nis your code that must call these routines, so just declaring a symbol as\nconstructor does nothing by itself.\n\nA constructor is always exported as an absolute (16 bit) symbol. You don't\nneed to use an additional `.export` statement, this is implied by\n`.constructor`. It may have an optional priority that is separated by a\ncomma. Higher numeric values mean a higher priority. If no priority is\ngiven, the default priority of 7 is used. Be careful when assigning\npriorities to your own module constructors so they won't interfere with the\nones in the cc65 library.\n\nExample:\n\n\n```ca65\n  .constructor    ModuleInit\n  .constructor    ModInit, 16\n  \n```\n\n\n\nSee the [`.CONDES`](https://cc65.github.io/doc/ca65.html#.CONDES) and [`.DESTRUCTOR`](https://cc65.github.io/doc/ca65.html#.DESTRUCTOR) commands and the separate section\n[Module constructors/destructors](https://cc65.github.io/doc/ca65.html#condes) explaining the\nfeature in more detail.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "incbin": {
      "documentation": "`.INCBIN`\n---\nInclude a file as binary data. The command expects a string argument\nthat is the name of a file to include literally in the current segment.\nIn addition to that, a start offset and a size value may be specified,\nseparated by commas. If no size is specified, all of the file from the\nstart offset to end-of-file is used. If no start position is specified\neither, zero is assumed (which means that the whole file is inserted).\n\nExample:\n\n\n```ca65\n  ; Include whole file\n  .incbin         \"sprites.dat\"\n\n  ; Include file starting at offset 256\n  .incbin         \"music.dat\", $100\n\n  ; Read 100 bytes starting at offset 200\n  .incbin         \"graphics.dat\", 200, 100\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "literal": {
      "documentation": "`.LITERAL`\n---\nDefine byte sized data. Must be followed by a sequence of (byte ranged)\nexpressions or strings. Strings will disregard the current character\nmapping definition and will be interpreted literally.\n\nExample:\n\n\n```ca65\n  .literal    \"Hello \"\n  .literal    \"world\", $0D, $00\n  \n```\n\n\n\nSee: [`.ASCIIZ`](https://cc65.github.io/doc/ca65.html#.ASCIIZ),[`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE)\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "pc02": {
      "documentation": "`.PC02`\n---\nEnable the 65C02 instructions set. This instruction set includes all\n6502 and 65SC02 instructions.\n\nSee: [`.P02`](https://cc65.github.io/doc/ca65.html#.P02), [`.PSC02`](https://cc65.github.io/doc/ca65.html#.PSC02), [`.P816`](https://cc65.github.io/doc/ca65.html#.P816) and\n[`.P4510`](https://cc65.github.io/doc/ca65.html#.P4510)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "global": {
      "documentation": "`.GLOBAL`\n---\nDeclare symbols as global. Must be followed by a comma separated list of\nsymbols to declare. Symbols from the list, that are defined somewhere in the\nsource, are exported, all others are imported. Additional [`.IMPORT`](https://cc65.github.io/doc/ca65.html#.IMPORT) or [`.EXPORT`](https://cc65.github.io/doc/ca65.html#.EXPORT) commands for the same symbol are allowed.\n\nExample:\n\n\n```ca65\n  .global foo, bar\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "warning": {
      "documentation": "`.WARNING`\n---\nForce an assembly warning. The assembler will output a warning message\npreceded by \"User warning\". This warning will always be output, even if\nother warnings are disabled with the [`-W0`](https://cc65.github.io/doc/ca65.html#option-W)\ncommand line option.\n\nThis command may be used to output possible problems when assembling\nthe source file.\n\nExample:\n\n\n```ca65\n  .macro  jne     target\n          .local L1\n          .ifndef target\n          .warning \"Forward jump in jne, cannot optimize!\"\n          beq     L1\n          jmp     target\n  L1:\n          .else\n          ...\n          .endif\n  .endmacro\n  \n```\n\n\n\nSee also: [`.ERROR`](https://cc65.github.io/doc/ca65.html#.ERROR),\n[`.FATAL`](https://cc65.github.io/doc/ca65.html#.FATAL),\n[`.OUT`](https://cc65.github.io/doc/ca65.html#.OUT)\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "pdtv": {
      "documentation": "`.PDTV`\n---\nEnable the 6502DTV instruction set. This is a superset of the 6502\ninstruction set.\n\nSee: [`.P02`](https://cc65.github.io/doc/ca65.html#.P02)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "a16": {
      "documentation": "`.A16`\n---\nValid only in 65816 mode. Assume the accumulator is 16 bit.\n\nNote: This command will not emit any code, it will tell the assembler to\ncreate 16 bit operands for immediate accumulator addressing mode.\n\nSee also: [`.SMART`](https://cc65.github.io/doc/ca65.html#.SMART)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "hibytes": {
      "documentation": "`.HIBYTES`\n---\nDefine byte sized data by extracting only the high byte (that is, bits 8-15) from\neach expression.  This is equivalent to [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE) with\nthe operator '>' prepended to each expression in its list.\n\nExample:\n\n\n```ca65\n  .lobytes         $1234, $2345, $3456, $4567\n  .hibytes         $fedc, $edcb, $dcba, $cba9\n  \n```\n\n\n\nwhich is equivalent to\n\n\n```ca65\n  .byte            $34, $45, $56, $67\n  .byte            $fe, $ed, $dc, $cb\n  \n```\n\n\n\nExample:\n\n\n```ca65\n  .define MyTable TableItem0, TableItem1, TableItem2, TableItem3\n\n  TableLookupLo:   .lobytes MyTable\n  TableLookupHi:   .hibytes MyTable\n  \n```\n\n\n\nwhich is equivalent to\n\n\n```ca65\n  TableLookupLo:   .byte <TableItem0, <TableItem1, <TableItem2, <TableItem3\n  TableLookupHi:   .byte >TableItem0, >TableItem1, >TableItem2, >TableItem3\n  \n```\n\n\n\nSee also: [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE),\n[`.LOBYTES`](https://cc65.github.io/doc/ca65.html#.LOBYTES),\n[`.BANKBYTES`](https://cc65.github.io/doc/ca65.html#.BANKBYTES)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "globalzp": {
      "documentation": "`.GLOBALZP`\n---\nDeclare symbols as global. Must be followed by a comma separated list of\nsymbols to declare. Symbols from the list, that are defined somewhere in the\nsource, are exported, all others are imported. Additional [`.IMPORTZP`](https://cc65.github.io/doc/ca65.html#.IMPORTZP) or [`.EXPORTZP`](https://cc65.github.io/doc/ca65.html#.EXPORTZP) commands for the same symbol are allowed. The symbols\nin the list are explicitly marked as zero page symbols.\n\nExample:\n\n\n```ca65\n  .globalzp foo, bar\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "segment": {
      "documentation": "`.SEGMENT`\n---\nSwitch to another segment. Code and data is always emitted into a\nsegment, that is, a named section of data. The default segment is\n\"CODE\". There may be up to 254 different segments per object file\n(and up to 65534 per executable). There are shortcut commands for\nthe most common segments (\"ZEROPAGE\", \"CODE\", \"RODATA\", \"DATA\", and \"BSS\").\n\nThe command is followed by a string containing the segment name (there are\nsome constraints for the name - as a rule of thumb use only those segment\nnames that would also be valid identifiers). There may also be an optional\naddress size separated by a colon. See the section covering [`address sizes`](https://cc65.github.io/doc/ca65.html#address-sizes) for more information.\n\nThe default address size for a segment depends on the memory model specified\non the command line. The default is \"absolute\", which means that you don't\nhave to use an address size modifier in most cases.\n\n\"absolute\" means that the is a segment with 16 bit (absolute) addressing.\nThat is, the segment will reside somewhere in core memory outside the zero\npage. \"zeropage\" (8 bit) means that the segment will be placed in the zero\npage and direct (short) addressing is possible for data in this segment.\n\nBeware: Only labels in a segment with the zeropage attribute are marked\nas reachable by short addressing. The '*' (PC counter) operator will\nwork as in other segments and will create absolute variable values.\n\nPlease note that a segment cannot have two different address sizes. A\nsegment specified as zeropage cannot be declared as being absolute later.\n\nExamples:\n\n\n```ca65\n  .segment \"ROM2\"                 ; Switch to ROM2 segment\n  .segment \"ZP2\": zeropage        ; New direct segment\n  .segment \"ZP2\"                  ; Ok, will use last attribute\n  .segment \"ZP2\": absolute        ; Error, redecl mismatch\n  \n```\n\n\n\nSee: [`.BSS`](https://cc65.github.io/doc/ca65.html#.BSS), [`.CODE`](https://cc65.github.io/doc/ca65.html#.CODE), [`.DATA`](https://cc65.github.io/doc/ca65.html#.DATA), [`.RODATA`](https://cc65.github.io/doc/ca65.html#.RODATA), and [`.ZEROPAGE`](https://cc65.github.io/doc/ca65.html#.ZEROPAGE)\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "popcpu": {
      "documentation": "`.POPCPU`\n---\nPop the last CPU setting from the stack, and activate it.\n\nThis command will switch back to the CPU that was last pushed onto the CPU\nstack using the [`.PUSHCPU`](https://cc65.github.io/doc/ca65.html#.PUSHCPU) command, and\nremove this entry from the stack.\n\nThe assembler will print an error message if the CPU stack is empty when\nthis command is issued.\n\nSee: [`.CPU`](https://cc65.github.io/doc/ca65.html#.CPU), [`.PUSHCPU`](https://cc65.github.io/doc/ca65.html#.PUSHCPU), [`.SETCPU`](https://cc65.github.io/doc/ca65.html#.SETCPU)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "concat": {
      "documentation": "`.CONCAT`\n---\nBuiltin string function. The function allows to concatenate a list of string\nconstants separated by commas. The result is a string constant that is the\nconcatenation of all arguments. This function is most useful in macros and\nwhen used together with the `.STRING` builtin function. The function may\nbe used in any case where a string constant is expected.\n\nExample:\n\n\n```ca65\n  .include        .concat (\"myheader\", \".\", \"inc\")\n  \n```\n\n\n\nThis is the same as the command\n\n\n```ca65\n  .include        \"myheader.inc\"\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "popseg": {
      "documentation": "`.POPSEG`\n---\nPop the last pushed segment from the stack, and set it.\n\nThis command will switch back to the segment that was last pushed onto the\nsegment stack using the [`.PUSHSEG`](https://cc65.github.io/doc/ca65.html#.PUSHSEG)\ncommand, and remove this entry from the stack.\n\nThe assembler will print an error message if the segment stack is empty\nwhen this command is issued.\n\nSee: [`.PUSHSEG`](https://cc65.github.io/doc/ca65.html#.PUSHSEG)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "else": {
      "documentation": "`.ELSE`\n---\nConditional assembly: Reverse the current condition.\n\n",
      "snippet_type": "ca65_else"
    },
    "defined": {
      "documentation": "`.DEF, .DEFINED`\n---\nBuiltin function. The function expects an identifier as argument in parentheses.\nThe argument is evaluated, and the function yields \"true\" if the identifier\nis a symbol that already is defined somewhere in the source file up to the\ncurrent position. Otherwise, the function yields false. As an example, the\n[`.IFDEF`](https://cc65.github.io/doc/ca65.html#.IFDEF) statement may be replaced by\n\n\n```ca65\n  .if     .defined(a)\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "match": {
      "documentation": "`.MATCH`\n---\nBuiltin function. Matches two token lists against each other. This is\nmost useful within macros, since macros are not stored as strings, but\nas lists of tokens.\n\nThe syntax is\n\n\n```ca65\n  .MATCH(<token list #1>, <token list #2>)\n  \n```\n\n\n\nBoth token list may contain arbitrary tokens with the exception of the\nterminator token (comma resp. right parenthesis) and\n\n\n\n\n- end-of-line\n\n- end-of-file\n\n\n\n\nThe token lists may optionally be enclosed into curly braces. This allows\nthe inclusion of tokens that would otherwise terminate the list (the closing\nright paren in the given case). Often a macro parameter is used for any of\nthe token lists.\n\nPlease note that the function does only compare tokens, not token\nattributes. So any number is equal to any other number, regardless of the\nactual value. The same is true for strings. If you need to compare tokens\n_and_ token attributes, use the [`.XMATCH`](https://cc65.github.io/doc/ca65.html#.XMATCH) function.\n\nExample:\n\nAssume the macro `ASR`, that will shift right the accumulator by one,\nwhile honoring the sign bit. The builtin processor instructions will allow\nan optional \"A\" for accu addressing for instructions like `ROL` and\n`ROR`. We will use the [`.MATCH`](https://cc65.github.io/doc/ca65.html#.MATCH) function\nto check for this and print and error for invalid calls.\n\n\n```ca65\n  .macro  asr     arg\n\n          .if (.not .blank(arg)) .and (.not .match ({arg}, a))\n          .error \"Syntax error\"\n          .endif\n\n          cmp     #$80            ; Bit 7 into carry\n          lsr     a               ; Shift carry into bit 7\n\n  .endmacro\n  \n```\n\n\n\nThe macro will only accept no arguments, or one argument that must be the\nreserved keyword \"A\".\n\nSee: [`.XMATCH`](https://cc65.github.io/doc/ca65.html#.XMATCH)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "define": {
      "documentation": "`.DEFINE`\n---\nStart a define style macro definition. The command is followed by an\nidentifier (the macro name) and optionally by a list of formal arguments\nin parentheses.\n\nPlease note that `.DEFINE` shares most disadvantages with its C\ncounterpart, so the general advice is,  do use `.DEFINE` if you\ndon't have to.\n\nSee also the [`.UNDEFINE`](https://cc65.github.io/doc/ca65.html#.UNDEFINE) command and\nsection \n[Macros](https://cc65.github.io/doc/ca65.html#macros).\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "scope": {
      "documentation": "`.SCOPE`\n---\nStart a nested lexical level with the given name. All new symbols from now\non are in the local lexical level and are accessible from outside only via\n[explicit scope specification](https://cc65.github.io/doc/ca65.html#scopesyntax). Symbols defined\noutside this local level may be accessed as long as their names are not used\nfor new symbols inside the level. Symbols names in other lexical levels do\nnot clash, so you may use the same names for identifiers. The lexical level\nends when the [`.ENDSCOPE`](https://cc65.github.io/doc/ca65.html#.ENDSCOPE) command is\nread. Lexical levels may be nested up to a depth of 16 (this is an\nartificial limit to protect against errors in the source).\n\nNote: Macro names are always in the global level and in a separate name\nspace. There is no special reason for this, it's just that I've never\nhad any need for local macro definitions.\n\nExample:\n\n\n```ca65\n  .scope  Error                   ; Start new scope named Error\n          None = 0                ; No error\n          File = 1                ; File error\n          Parse = 2               ; Parse error\n  .endscope                       ; Close lexical level\n\n          ...\n          lda #Error::File        ; Use symbol from scope Error\n  \n```\n\n\n\nSee: [`.ENDSCOPE`](https://cc65.github.io/doc/ca65.html#.ENDSCOPE) and [`.PROC`](https://cc65.github.io/doc/ca65.html#.PROC)\n\n",
      "snippet_type": "ca65_keyword_block"
    },
    "macro": {
      "documentation": "`.MAC, .MACRO`\n---\nStart a classic macro definition. The command is followed by an identifier\n(the macro name) and optionally by a comma separated list of identifiers\nthat are macro parameters. A macro definition is terminated by [`.ENDMACRO`](https://cc65.github.io/doc/ca65.html#.ENDMACRO).\n\nExample:\n\n\n```ca65\n  .macro  ldax    arg             ; Define macro ldax\n          lda     arg\n          ldx     arg+1\n  \n```\n\n\n\nSee: [`.DELMACRO`](https://cc65.github.io/doc/ca65.html#.DELMACRO),\n[`.ENDMACRO`](https://cc65.github.io/doc/ca65.html#.ENDMACRO),\n[`.EXITMACRO`](https://cc65.github.io/doc/ca65.html#.EXITMACRO)\n\nSee also section \n[Macros](https://cc65.github.io/doc/ca65.html#macros).\n\n",
      "snippet_type": "ca65_keyword_block"
    },
    "set": {
      "documentation": "`.SET`\n---\n`.SET` is used to assign a value to a variable. See \n[Numeric variables](https://cc65.github.io/doc/ca65.html#variables) for a full description.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "ifconst": {
      "documentation": "`.IFCONST`\n---\nConditional assembly: Evaluate an expression and switch assembler output\non or off depending on the constness of the expression.\n\nA const expression evaluates to to TRUE, a non const expression (one\ncontaining an imported or currently undefined symbol) evaluates to\nFALSE.\n\nSee also: [`.CONST`](https://cc65.github.io/doc/ca65.html#.CONST)\n\n",
      "snippet_type": "ca65_if_param"
    },
    "ismnemonic": {
      "documentation": "`.ISMNEM, .ISMNEMONIC`\n---\nBuiltin function. The function expects an identifier as argument in parentheses.\nThe argument is evaluated, and the function yields \"true\" if the identifier\nis defined as an instruction mnemonic that is recognized by the assembler.\nExample:\n\n\n```ca65\n  .if     .not .ismnemonic(ina)\n          .macro ina\n                  clc\n                  adc #$01\n          .endmacro\n  .endif\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "endmacro": {
      "documentation": "`.ENDMAC, .ENDMACRO`\n---\nMarks the end of a macro definition. Note, `.ENDMACRO` should be on\nits own line to successfully end the macro definition. It is possible to use\n[`.DEFINE`](https://cc65.github.io/doc/ca65.html#.DEFINE) to create a symbol that references\n`.ENDMACRO` without ending the macro definition.\n\nExample:\n\n\n```ca65\n  .macro  new_mac\n          .define startmac .macro\n          .define endmac .endmacro\n  .endmacro\n  \n```\n\n\n\nSee: [`.DELMACRO`](https://cc65.github.io/doc/ca65.html#.DELMACRO),\n[`.EXITMACRO`](https://cc65.github.io/doc/ca65.html#.EXITMACRO),\n[`.MACRO`](https://cc65.github.io/doc/ca65.html#.MACRO)\n\nSee also section \n[Macros](https://cc65.github.io/doc/ca65.html#macros).\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "cpu": {
      "documentation": "`.CPU`\n---\nReading this pseudo variable will give a constant integer value that\ntells which CPU is currently enabled. It can also tell which instruction\nset the CPU is able to translate. The value read from the pseudo variable\nshould be further examined by using one of the constants defined by the\n\"cpu\" macro package (see [`.MACPACK`](https://cc65.github.io/doc/ca65.html#.MACPACK)).\n\nIt may be used to replace the .IFPxx pseudo instructions or to construct\neven more complex expressions.\n\nExample:\n\n\n```ca65\n  .macpack        cpu\n  .if     (.cpu .bitand CPU_ISET_65816)\n          phx\n          phy\n  .else\n          txa\n          pha\n          tya\n          pha\n  .endif\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "endstruct": {
      "documentation": "`.ENDSTRUCT`\n---\nEnds a struct definition. See the [`.STRUCT`](https://cc65.github.io/doc/ca65.html#.STRUCT)\ncommand and the separate section named \n[Structs   and unions](https://cc65.github.io/doc/ca65.html#structs).\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "ifref": {
      "documentation": "`.IFREF`\n---\nConditional assembly: Check if a symbol is referenced. Must be followed\nby a symbol name. The condition is true if the given symbol was\nreferenced before, and false otherwise.\n\nThis command may be used to build subroutine libraries in include files\n(you may use separate object modules for this purpose too).\n\nExample:\n\n\n```ca65\n  .ifref  ToHex                   ; If someone used this subroutine\n  ToHex:  tay                     ; Define subroutine\n          lda     HexTab,y\n          rts\n  .endif\n  \n```\n\n\n\nSee also: [`.REFERENCED`](https://cc65.github.io/doc/ca65.html#.REFERENCED), and\n[`.REFERTO`](https://cc65.github.io/doc/ca65.html#.REFERTO)\n\n",
      "snippet_type": "ca65_if_param"
    },
    "fatal": {
      "documentation": "`.FATAL`\n---\nForce an assembly error and terminate assembly. The assembler will output an\nerror message preceded by \"User error\" and will terminate assembly\nimmediately.\n\nThis command may be used to check for initial conditions that must be\nset before assembling a source file.\n\nExample:\n\n\n```ca65\n  .if     foo = 1\n  ...\n  .elseif bar = 1\n  ...\n  .else\n  .fatal  \"Must define foo or bar!\"\n  .endif\n  \n```\n\n\n\nSee also: [`.ERROR`](https://cc65.github.io/doc/ca65.html#.ERROR),\n[`.OUT`](https://cc65.github.io/doc/ca65.html#.OUT),\n[`.WARNING`](https://cc65.github.io/doc/ca65.html#.WARNING)\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "ifpdtv": {
      "documentation": "`.IFPDTV`\n---\nConditional assembly: Check if the assembler is currently in 6502DTV mode\n(see [`.PDTV`](https://cc65.github.io/doc/ca65.html#.PDTV) command).\n\n",
      "snippet_type": "ca65_if_no_param"
    },
    "lobytes": {
      "documentation": "`.LOBYTES`\n---\nDefine byte sized data by extracting only the low byte (that is, bits 0-7) from\neach expression.  This is equivalent to [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE) with\nthe operator '<' prepended to each expression in its list.\n\nExample:\n\n\n```ca65\n  .lobytes         $1234, $2345, $3456, $4567\n  .hibytes         $fedc, $edcb, $dcba, $cba9\n  \n```\n\n\n\nwhich is equivalent to\n\n\n```ca65\n  .byte            $34, $45, $56, $67\n  .byte            $fe, $ed, $dc, $cb\n  \n```\n\n\n\nExample:\n\n\n```ca65\n  .define MyTable TableItem0, TableItem1, TableItem2, TableItem3\n\n  TableLookupLo:   .lobytes MyTable\n  TableLookupHi:   .hibytes MyTable\n  \n```\n\n\n\nwhich is equivalent to\n\n\n```ca65\n  TableLookupLo:   .byte <TableItem0, <TableItem1, <TableItem2, <TableItem3\n  TableLookupHi:   .byte >TableItem0, >TableItem1, >TableItem2, >TableItem3\n  \n```\n\n\n\nSee also: [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE),\n[`.HIBYTES`](https://cc65.github.io/doc/ca65.html#.HIBYTES),\n[`.BANKBYTES`](https://cc65.github.io/doc/ca65.html#.BANKBYTES)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "export": {
      "documentation": "`.EXPORT`\n---\nMake symbols accessible from other modules. Must be followed by a comma\nseparated list of symbols to export, with each one optionally followed by an\naddress specification and (also optional) an assignment. Using an additional\nassignment in the export statement allows to define and export a symbol in\none statement. The default is to export the symbol with the address size it\nactually has. The assembler will issue a warning, if the symbol is exported\nwith an address size smaller than the actual address size.\n\nExamples:\n\n\n```ca65\n  .export foo\n  .export bar: far\n  .export foobar: far = foo * bar\n  .export baz := foobar, zap: far = baz - bar\n  \n```\n\n\n\nAs with constant definitions, using `:=` instead of `=` marks the\nsymbols as a label.\n\nSee: [`.EXPORTZP`](https://cc65.github.io/doc/ca65.html#.EXPORTZP)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "ifndef": {
      "documentation": "`.IFNDEF`\n---\nConditional assembly: Check if a symbol is defined. Must be followed by\na symbol name. The condition is true if the given symbol is not\ndefined, and false otherwise.\n\nSee also: [`.DEFINED`](https://cc65.github.io/doc/ca65.html#.DEFINED)\n\n",
      "snippet_type": "ca65_if_param"
    },
    "ifp02": {
      "documentation": "`.IFP02`\n---\nConditional assembly: Check if the assembler is currently in 6502 mode\n(see [`.P02`](https://cc65.github.io/doc/ca65.html#.P02) command).\n\n",
      "snippet_type": "ca65_if_no_param"
    },
    "psc02": {
      "documentation": "`.PSC02`\n---\nEnable the 65SC02 instructions set. This instruction set includes all\n6502 instructions.\n\nSee: [`.P02`](https://cc65.github.io/doc/ca65.html#.P02), [`.PC02`](https://cc65.github.io/doc/ca65.html#.PC02), [`.P816`](https://cc65.github.io/doc/ca65.html#.P816) and\n[`.P4510`](https://cc65.github.io/doc/ca65.html#.P4510)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "list": {
      "documentation": "`.LIST`\n---\nEnable output to the listing. The command can be followed by a boolean\nswitch (\"on\", \"off\", \"+\" or \"-\") and will enable or disable listing\noutput.\nThe option has no effect if the listing is not enabled by the command line\nswitch -l. If -l is used, an internal counter is set to 1. Lines are output\nto the listing file, if the counter is greater than zero, and suppressed if\nthe counter is zero. Each use of `.LIST` will increment or decrement the\ncounter.\n\nExample:\n\n\n```ca65\n  .list   on              ; Enable listing output\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "max": {
      "documentation": "`.MAX`\n---\nBuiltin function. The result is the larger of two values.\n\nThe syntax is\n\n\n```ca65\n  .MAX (<value #1>, <value #2>)\n  \n```\n\n\n\nExample:\n\n\n```ca65\n  ; Reserve space for the larger of two data blocks\n  savearea:       .res .max (.sizeof (foo), .sizeof (bar))\n  \n```\n\n\n\nSee: [`.MIN`](https://cc65.github.io/doc/ca65.html#.MIN)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "struct": {
      "documentation": "`.STRUCT`\n---\nStarts a struct definition. Structs are covered in a separate section named\n[Structs and unions](https://cc65.github.io/doc/ca65.html#structs).\n\nSee also: [`.ENDSTRUCT`](https://cc65.github.io/doc/ca65.html#.ENDSTRUCT),\n[`.ENDUNION`](https://cc65.github.io/doc/ca65.html#.ENDUNION),\n[`.UNION`](https://cc65.github.io/doc/ca65.html#.UNION)\n\n",
      "snippet_type": "ca65_keyword_block"
    },
    "sprintf": {
      "documentation": "`.SPRINTF`\n---\nBuiltin function. It expects a format string as first argument. The number\nand type of the following arguments depend on the format string. The format\nstring is similar to the one of the C `printf` function. Missing things\nare: Length modifiers, variable width.\n\nThe result of the function is a string.\n\nExample:\n\n\n```ca65\n  num     = 3\n\n  ; Generate an identifier:\n  .ident (.sprintf (\"%s%03d\", \"label\", num)):\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function_string"
    },
    "ifpsc02": {
      "documentation": "`.IFPSC02`\n---\nConditional assembly: Check if the assembler is currently in 65SC02 mode\n(see [`.PSC02`](https://cc65.github.io/doc/ca65.html#.PSC02) command).\n\n",
      "snippet_type": "ca65_if_no_param"
    },
    "exitmacro": {
      "documentation": "`.EXITMAC, .EXITMACRO`\n---\nAbort a macro expansion immediately. This command is often useful in\nrecursive macros.\n\nSee: [`.DELMACRO`](https://cc65.github.io/doc/ca65.html#.DELMACRO),\n[`.ENDMACRO`](https://cc65.github.io/doc/ca65.html#.ENDMACRO),\n[`.MACRO`](https://cc65.github.io/doc/ca65.html#.MACRO)\n\nSee also section \n[Macros](https://cc65.github.io/doc/ca65.html#macros).\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "destructor": {
      "documentation": "`.DESTRUCTOR`\n---\nExport a symbol and mark it as a module destructor. This may be used\ntogether with the linker to build a table of destructor subroutines that\nare called by the startup code.\n\nNote: The linker has a feature to build a table of marked routines, but it\nis your code that must call these routines, so just declaring a symbol as\nconstructor does nothing by itself.\n\nA destructor is always exported as an absolute (16 bit) symbol. You don't\nneed to use an additional `.export` statement, this is implied by\n`.destructor`. It may have an optional priority that is separated by a\ncomma. Higher numerical values mean a higher priority. If no priority is\ngiven, the default priority of 7 is used. Be careful when assigning\npriorities to your own module destructors so they won't interfere with the\nones in the cc65 library.\n\nExample:\n\n\n```ca65\n  .destructor     ModuleDone\n  .destructor     ModDone, 16\n  \n```\n\n\n\nSee the [`.CONDES`](https://cc65.github.io/doc/ca65.html#.CONDES) and [`.CONSTRUCTOR`](https://cc65.github.io/doc/ca65.html#.CONSTRUCTOR) commands and the separate\nsection \n[Module constructors/destructors](https://cc65.github.io/doc/ca65.html#condes) explaining\nthe feature in more detail.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "tcount": {
      "documentation": "`.TCOUNT`\n---\nBuiltin function. The function accepts a token list in parentheses. The function\nresult is the number of tokens given as argument. The token list may\noptionally be enclosed into curly braces which are not considered part of\nthe list and not counted. Enclosement in curly braces allows the inclusion\nof tokens that would otherwise terminate the list (the closing right paren\nin the given case).\n\nExample:\n\nThe `ldax` macro accepts the '#' token to denote immediate addressing (as\nwith the normal 6502 instructions). To translate it into two separate 8 bit\nload instructions, the '#' token has to get stripped from the argument:\n\n\n```ca65\n  .macro  ldax    arg\n          .if (.match (.mid (0, 1, {arg}), #))\n          ; ldax called with immediate operand\n          lda     #<(.right (.tcount ({arg})-1, {arg}))\n          ldx     #>(.right (.tcount ({arg})-1, {arg}))\n          .else\n          ...\n          .endif\n  .endmacro\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "smart": {
      "documentation": "`.SMART`\n---\nSwitch on or off smart mode. The command can be followed by a '+' or '-'\ncharacter to switch the option on or off respectively. The default is off\n(that is, the assembler doesn't try to be smart), but this default may be\nchanged by the -s switch on the command line.\n\nIn smart mode the assembler will do the following:\n\n\n\n\n- Track usage of the `REP` and `SEP` instructions in 65816 mode\nand update the operand sizes accordingly. If the operand of such an\ninstruction cannot be evaluated by the assembler (for example, because\nthe operand is an imported symbol), a warning is issued. Beware: Since\nthe assembler cannot trace the execution flow this may lead to false\nresults in some cases. If in doubt, use the `.Inn` and `.Ann`\ninstructions to tell the assembler about the current settings.\n\n- In 65816 mode, if the [`long_jsr_jmp_rts`](https://cc65.github.io/doc/ca65.html#long_jsr_jmp_rts) feature is enabled,\nsmart mode will replace a `RTS` instruction by `RTL` if it is\nused within a procedure declared as `far`, or if the procedure has\nno explicit address specification, but it is `far` because of the\nmemory model used.\n\n\n\n\nExample:\n\n\n```ca65\n  .smart                          ; Be smart\n  .smart  -                       ; Stop being smart\n  \n```\n\n\n\nSee: [`.A16`](https://cc65.github.io/doc/ca65.html#.A16),\n[`.A8`](https://cc65.github.io/doc/ca65.html#.A8),\n[`.I16`](https://cc65.github.io/doc/ca65.html#.I16),\n[`.I8`](https://cc65.github.io/doc/ca65.html#.I8)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "xmatch": {
      "documentation": "`.XMATCH`\n---\nBuiltin function. Matches two token lists against each other. This is\nmost useful within macros, since macros are not stored as strings, but\nas lists of tokens.\n\nThe syntax is\n\n\n```ca65\n  .XMATCH(<token list #1>, <token list #2>)\n  \n```\n\n\n\nBoth token list may contain arbitrary tokens with the exception of the\nterminator token (comma resp. right parenthesis) and\n\n\n\n\n- end-of-line\n\n- end-of-file\n\n\n\n\nThe token lists may optionally be enclosed into curly braces. This allows\nthe inclusion of tokens that would otherwise terminate the list (the closing\nright paren in the given case). Often a macro parameter is used for any of\nthe token lists.\n\nThe function compares tokens _and_ token values. If you need a function\nthat just compares the type of tokens, have a look at the [`.MATCH`](https://cc65.github.io/doc/ca65.html#.MATCH) function.\n\nSee: [`.MATCH`](https://cc65.github.io/doc/ca65.html#.MATCH)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "min": {
      "documentation": "`.MIN`\n---\nBuiltin function. The result is the smaller of two values.\n\nThe syntax is\n\n\n```ca65\n  .MIN (<value #1>, <value #2>)\n  \n```\n\n\n\nExample:\n\n\n```ca65\n  ; Reserve space for some data, but 256 bytes maximum\n  savearea:       .res .min (.sizeof (foo), 256)\n  \n```\n\n\n\nSee: [`.MAX`](https://cc65.github.io/doc/ca65.html#.MAX)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "i8": {
      "documentation": "`.I8`\n---\nValid only in 65816 mode. Assume the index registers are 8 bit.\n\nNote: This command will not emit any code, it will tell the assembler to\ncreate 8 bit operands for immediate operands.\n\nSee also the [`.I16`](https://cc65.github.io/doc/ca65.html#.I16) and [`.SMART`](https://cc65.github.io/doc/ca65.html#.SMART) commands.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "endproc": {
      "documentation": "`.ENDPROC`\n---\nEnd of the local lexical level (see [`.PROC`](https://cc65.github.io/doc/ca65.html#.PROC)).\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "strat": {
      "documentation": "`.STRAT`\n---\nBuiltin function. The function accepts a string and an index as\narguments and returns the value of the character at the given position\nas an integer value. The index is zero based.\n\nExample:\n\n\n```ca65\n  .macro  M       Arg\n          ; Check if the argument string starts with '#'\n          .if (.strat (Arg, 0) = '#')\n          ...\n          .endif\n  .endmacro\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "autoimport": {
      "documentation": "`.AUTOIMPORT`\n---\nIs followed by a plus or a minus character. When switched on (using a\n+), undefined symbols are automatically marked as import instead of\ngiving errors. When switched off (which is the default so this does not\nmake much sense), this does not happen and an error message is\ndisplayed. The state of the autoimport flag is evaluated when the\ncomplete source was translated, before outputting actual code, so it is\n_not_ possible to switch this feature on or off for separate sections\nof code. The last setting is used for all symbols.\n\nYou should probably not use this switch because it delays error\nmessages about undefined symbols until the link stage. The cc65\ncompiler (which is supposed to produce correct assembler code in all\ncircumstances, something which is not true for most assembler\nprogrammers) will insert this command to avoid importing each and every\nroutine from the runtime library.\n\nExample:\n\n\n```ca65\n  .autoimport     +       ; Switch on auto import\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "fopt": {
      "documentation": "`.FILEOPT, .FOPT`\n---\nInsert an option string into the object file. There are two forms of\nthis command, one specifies the option by a keyword, the second\nspecifies it as a number. Since usage of the second one needs knowledge\nof the internal encoding, its use is not recommended and I will only\ndescribe the first form here.\n\nThe command is followed by one of the keywords\n\n\n```ca65\n  author\n  comment\n  compiler\n  \n```\n\n\n\na comma and a string. The option is written into the object file\ntogether with the string value. This is currently unidirectional and\nthere is no way to actually use these options once they are in the\nobject file.\n\nExamples:\n\n\n```ca65\n  .fileopt        comment, \"Code stolen from my brother\"\n  .fileopt        compiler, \"BASIC 2.0\"\n  .fopt           author, \"J. R. User\"\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "rodata": {
      "documentation": "`.RODATA`\n---\nSwitch to the RODATA segment. The name of the RODATA segment is always\n\"RODATA\", so this is a shortcut for\n\n\n```ca65\n  .segment  \"RODATA\"\n  \n```\n\n\n\nThe RODATA segment is a segment that is used by the compiler for\nreadonly data like string constants.\n\nSee also the [`.SEGMENT`](https://cc65.github.io/doc/ca65.html#.SEGMENT) command.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "tag": {
      "documentation": "`.TAG`\n---\nAllocate space for a struct or union. This is equivalent to\n[`.RES`](https://cc65.github.io/doc/ca65.html#.RES) with the\n[`.SIZEOF`](https://cc65.github.io/doc/ca65.html#.SIZEOF) of a struct.\n\nExample:\n\n\n```ca65\n  .struct Point\n          xcoord  .word\n          ycoord  .word\n  .endstruct\n\n  .bss\n          .tag    Point           ; Allocate 4 bytes\n  \n```\n\n\n\nSee: \n[Structs and unions](https://cc65.github.io/doc/ca65.html#structs)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "version": {
      "documentation": "`.VERSION`\n---\nReading this pseudo variable will give the assembler version according to\nthe following formula:\n\n`(VER_MAJOR * 0x100) + VER_MINOR`\n\nThe upper 8 bits are the major-, the lower 8 bits are the  minor version.\n\nExample:\n\nFor example, version 47.11 of the assembler would have this macro defined as\n`0x2f0b`.\n\nNote: until 2.19 this pseudo variable was defined as `(VER_MAJOR * 0x100) + VER_MINOR * 0x10` -\nwhich resulted in broken values starting at version 2.16 of the assembler. For\nthis reason the value of this pseudo variable is considered purely informal - you should\nnot use it to check for a specific assembler version and use different code\naccording to the detected version - please update your code to work with the\nrecent version of the assembler instead (There is very little reason to not use\nthe most recent version - and even less to support older versions in your code).\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "asize": {
      "documentation": "`.ASIZE`\n---\nReading this pseudo variable will return the current size of the\nAccumulator in bits.\n\nFor the 65816 instruction set .ASIZE will return either 8 or 16, depending\non the current size of the operand in immediate accu addressing mode.\n\nFor all other CPU instruction sets, .ASIZE will always return 8.\n\nExample:\n\n\n```ca65\n  ; Reverse Subtract with Accumulator\n  ; A = memory - A\n  .macro rsb param\n          .if .asize = 8\n                  eor     #$ff\n          .else\n                  eor     #$ffff\n          .endif\n          sec\n          adc     param\n  .endmacro\n```\n\n\n\nSee also: [`.ISIZE`](https://cc65.github.io/doc/ca65.html#.ISIZE)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "pushcpu": {
      "documentation": "`.PUSHCPU`\n---\nPush the currently active CPU onto a stack. The stack has a size of 8\nentries.\n\n`.PUSHCPU` allows together with [`.POPCPU`](https://cc65.github.io/doc/ca65.html#.POPCPU) to switch to another CPU and to restore the old CPU\nlater, without knowledge of the current CPU setting.\n\nThe assembler will print an error message if the CPU stack is already full,\nwhen this command is issued.\n\nSee: [`.CPU`](https://cc65.github.io/doc/ca65.html#.CPU), [`.POPCPU`](https://cc65.github.io/doc/ca65.html#.POPCPU), [`.SETCPU`](https://cc65.github.io/doc/ca65.html#.SETCPU)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "endif": {
      "documentation": "`.ENDIF`\n---\nConditional assembly: Close a [`.IF...`](https://cc65.github.io/doc/ca65.html#.IF) or\n[`.ELSE`](https://cc65.github.io/doc/ca65.html#.ELSE) branch.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "include": {
      "documentation": "`.INCLUDE`\n---\nInclude another file. Include files may be nested up to a depth of 16.\n\nExample:\n\n\n```ca65\n  .include        \"subs.inc\"\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "union": {
      "documentation": "`.UNION`\n---\nStarts a union definition. Unions are covered in a separate section named\n[Structs and unions](https://cc65.github.io/doc/ca65.html#structs).\n\nSee also: [`.ENDSTRUCT`](https://cc65.github.io/doc/ca65.html#.ENDSTRUCT),\n[`.ENDUNION`](https://cc65.github.io/doc/ca65.html#.ENDUNION),\n[`.STRUCT`](https://cc65.github.io/doc/ca65.html#.STRUCT)\n\n",
      "snippet_type": "ca65_keyword_block"
    },
    "definedmacro": {
      "documentation": "`.DEFINEDMACRO`\n---\nBuiltin function. The function expects an identifier as argument in parentheses.\nThe argument is evaluated, and the function yields \"true\" if the identifier\nalready has been defined as the name of a macro. Otherwise, the function yields\nfalse. Example:\n\n\n```ca65\n  .macro add foo\n          clc\n          adc foo\n  .endmacro\n\n  .if     .definedmacro(add)\n          add #$01\n  .else\n          clc\n          adc #$01\n  .endif\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "dword": {
      "documentation": "`.DWORD`\n---\nDefine dword sized data (4 bytes) Must be followed by a sequence of\nexpressions.\n\nExample:\n\n\n```ca65\n  .dword  $12344512, $12FA489\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "asciiz": {
      "documentation": "`.ASCIIZ`\n---\nDefine a string with a trailing zero.\n\nExample:\n\n\n```ca65\n  Msg:    .asciiz \"Hello world\"\n  \n```\n\n\n\nThis will put the string \"Hello world\" followed by a binary zero into\nthe current segment. There may be more strings separated by commas, but\nthe binary zero is only appended once (after the last one). Strings will\nbe translated using the current character mapping definition.\n\nSee: [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE),[`.CHARMAP`](https://cc65.github.io/doc/ca65.html#.CHARMAP),\n[`.LITERAL`](https://cc65.github.io/doc/ca65.html#.LITERAL)\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "ifnblank": {
      "documentation": "`.IFNBLANK`\n---\nConditional assembly: Check if there are any remaining tokens in this line,\nand evaluate to TRUE if this is the case, and to FALSE otherwise. If the\ncondition is not true, further lines are not assembled until an [`.ELSE`](https://cc65.github.io/doc/ca65.html#.ELSE), [`.ELSEIF`](https://cc65.github.io/doc/ca65.html#.ELSEIF) or\n[`.ENDIF`](https://cc65.github.io/doc/ca65.html#.ENDIF) directive.\n\nThis command is often used to check if a macro parameter was given.\nSince an empty macro parameter will evaluate to nothing, the condition\nwill evaluate to FALSE if an empty parameter was given.\n\nExample:\n\n\n```ca65\n  .macro     arg1, arg2\n             lda     #arg1\n  .ifnblank  arg2\n             lda     #arg2\n  .endif\n  .endmacro\n  \n```\n\n\n\nSee also: [`.BLANK`](https://cc65.github.io/doc/ca65.html#.BLANK)\n\n",
      "snippet_type": "ca65_if_param"
    },
    "ifdef": {
      "documentation": "`.IFDEF`\n---\nConditional assembly: Check if a symbol is defined. Must be followed by\na symbol name. The condition is true if the given symbol is already\ndefined, and false otherwise.\n\nSee also: [`.DEFINED`](https://cc65.github.io/doc/ca65.html#.DEFINED)\n\n",
      "snippet_type": "ca65_if_param"
    },
    "mid": {
      "documentation": "`.MID`\n---\nBuiltin function. Takes a starting index, a count and a token list as\narguments. Will return part of the token list.\n\nSyntax:\n\n\n```ca65\n  .MID (<int expr>, <int expr>, <token list>)\n  \n```\n\n\n\nThe first integer expression gives the starting token in the list (the first\ntoken has index 0). The second integer expression gives the number of tokens\nto extract from the token list. The third argument is the token list itself.\nThe token list may optionally be enclosed into curly braces. This allows the\ninclusion of tokens that would otherwise terminate the list (the closing\nright paren in the given case).\n\nExample:\n\nTo check in a macro if the given argument has a '`#`' as first token\n(immediate addressing mode), use something like this:\n\n\n```ca65\n  .macro  ldax    arg\n          ...\n          .if (.match (.mid (0, 1, {arg}), #))\n\n          ; ldax called with immediate operand\n          ...\n\n          .endif\n          ...\n  .endmacro\n  \n```\n\n\n\nSee also the [`.LEFT`](https://cc65.github.io/doc/ca65.html#.LEFT) and [`.RIGHT`](https://cc65.github.io/doc/ca65.html#.RIGHT) builtin functions.\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "endenum": {
      "documentation": "`.ENDENUM`\n---\nEnd a [`.ENUM`](https://cc65.github.io/doc/ca65.html#.ENUM) declaration.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "code": {
      "documentation": "`.CODE`\n---\nSwitch to the CODE segment. The name of the CODE segment is always\n\"CODE\", so this is a shortcut for\n\n\n```ca65\n  .segment  \"CODE\"\n  \n```\n\n\n\nSee also the [`.SEGMENT`](https://cc65.github.io/doc/ca65.html#.SEGMENT) command.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "strlen": {
      "documentation": "`.STRLEN`\n---\nBuiltin function. The function accepts a string argument in parentheses and\nevaluates to the length of the string.\n\nExample:\n\nThe following macro encodes a string as a pascal style string with\na leading length byte.\n\n\n```ca65\n  .macro  PString Arg\n          .byte   .strlen(Arg), Arg\n  .endmacro\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "feature": {
      "documentation": "`.FEATURE`\n---\nThis directive may be used to enable one or more compatibility features\nof the assembler. While the use of `.FEATURE` should be avoided when\npossible, it may be useful when porting sources written for other\nassemblers. After the feature name an optional '+' or '-' may specify whether\nto enable or disable the feature (enable if omitted). Multiple features may be\nenabled, separated by commas. Examples:\n\n\n```ca65\n  ; enable c_comments\n  .feature   c_comments\n  .feature   c_comments +\n  ; enable force_range, disable underline_in_numbers, enable labels_without_colons\n  .feature   force_range, underline_in_numbers -, labels_without_colons +\n  .feature   force_range +, underline_in_numbers off, labels_without_colons on\n  \n```\n\n\n\nThe following features are available:\n\n\n\n### `at_in_identifiers`\n\nAccept the at character ('@') as a valid character in identifiers. The\nat character is not allowed to start an identifier, even with this\nfeature enabled.\n\n\n### `bracket_as_indirect`\n\nUse `[]` instead of `()` for the indirect addressing modes.\nExample:\n\n\n```ca65\n  lda     [$82]\n  lda     [$82,x]\n  lda     [$82],y\n  jmp     [$fffe]\n  jmp     [table,x]\n  \n```\n\n\n_Note:_ This should not be used in 65186 mode because it conflicts with\nthe 65816 instruction syntax for far addressing. See the section covering\n[`address sizes`](https://cc65.github.io/doc/ca65.html#address-sizes) for more information.\n\n\n### `c_comments`\n\nAllow C like comments using `/*` and `*/` as left and right\ncomment terminators. Note that C comments may not be nested. There's also a\npitfall when using C like comments: All statements must be terminated by\n\"end-of-line\". Using C like comments, it is possible to hide the newline,\nwhich results in error messages. See the following non working example:\n\n\n```ca65\n  lda     #$00  /* This comment hides the newline\n*/      sta     $82\n  \n```\n\n\n\n\n### `dollar_in_identifiers`\n\nAccept the dollar sign ('$') as a valid character in identifiers. The\ndollar character is not allowed to start an identifier, even with this\nfeature enabled.\n\n\n### `dollar_is_pc`\n\nThe dollar sign may be used as an alias for the star ('*'), which\ngives the value of the current PC in expressions.\nNote: Assignment to the pseudo variable is not allowed.\n\n\n### `force_range`\n\nForce expressions into their valid range for immediate addressing and\nstorage operators like [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE) and\n[`.WORD`](https://cc65.github.io/doc/ca65.html#.WORD). Be very careful with this one,\nsince it will completely disable error checks.\n\n\n### `labels_without_colons`\n\nAllow labels without a trailing colon. These labels are only accepted,\nif they start at the beginning of a line (no leading white space).\n\n\n### `leading_dot_in_identifiers`\n\nAccept the dot ('.') as the first character of an identifier. This may be\nused for example to create macro names that start with a dot emulating\ncontrol directives of other assemblers. Note however, that none of the\nreserved keywords built into the assembler, that starts with a dot, may be\noverridden. When using this feature, you may also get into trouble if\nlater versions of the assembler define new keywords starting with a dot.\n\n\n### `line_continuations`\n\nSwitch on or off line continuations using the backslash character\nbefore a newline. The option is off by default.\nNote: Line continuations do not work in a comment. A backslash at the\nend of a comment is treated as part of the comment and does not trigger\nline continuation.\n\nExample:\n\n\n```ca65\n    .feature line_continuations +   ; Allow line continuations\n\n    lda     \\\n            #$20                    ; This is legal now\n  \n```\n\n\n\nFor backward compatibility reasons, the `.LINECONT +` control command\nis also supported and enables the same feature.\n\n\n### `long_jsr_jmp_rts`\n\nAffects 65816 mode only.\n\nAllows `jsr` and `jmp` to produce long jumps if the target\naddress has been previously declared in a `far` segment,\nor imported as `far`.\nOtherwise `jsl` and `jml` must be used instead.\n\nAlso allows [`.SMART`](https://cc65.github.io/doc/ca65.html#.SMART) to convert `rts`\nto a long return `rtl` when the enclosing scope or memory model\nindicates returning from a `far` procedure.\n\nThis permits compatibility with the old behavior of this assembler, or other\nassemblers which similarly allowed `jsr` and `jmp` to be used\nthis way.\n\n\n### `loose_char_term`\n\nAccept single quotes as well as double quotes as terminators for char\nconstants.\n\n\n### `loose_string_term`\n\nAccept single quotes as well as double quotes as terminators for string\nconstants.\n\n\n### `missing_char_term`\n\nAccept single quoted character constants where the terminating quote is\nmissing.\n```ca65\n  lda     #'a\n  \n```\n\n\n_Note:_ This does not work in conjunction with `.FEATUREloose_string_term`, since in this case the input would be ambiguous.\n\n\n### `org_per_seg`\n\nThis feature makes relocatable/absolute mode local to the current segment.\nUsing [`.ORG`](https://cc65.github.io/doc/ca65.html#.ORG) when `org_per_seg` is in\neffect will only enable absolute mode for the current segment. Dito for\n[`.RELOC`](https://cc65.github.io/doc/ca65.html#.RELOC).\n\n\n### `pc_assignment`\n\nAllow assignments to the PC symbol ('*' or '$' if `dollar_is_pc`\nis enabled). Such an assignment is handled identical to the [`.ORG`](https://cc65.github.io/doc/ca65.html#.ORG) command (which is usually not needed, so just\nremoving the lines with the assignments may also be an option when porting\ncode written for older assemblers).\n\n\n### `string_escapes`\n\nAllow C-style backslash escapes within string constants to embed\nspecial characters. The following escapes are accepted:\n\n\n- `\\\\` backslash (`$5C`)\n\n- `\\'` single quote (`$27`)\n\n- `\\&#34;` double quote (`$22`)\n\n- `\\t` tab (`$09`)\n\n- `\\r` carriage return (`$0D`)\n\n- `\\n` newline (`$0A`)\n\n- `\\xNN`  (`$NN`)\n\n\n\n\nNote that string escapes are converted to platform-specific characters in\nthe same way that other characters are converted.\n\n\n### `ubiquitous_idents`\n\nAllow the use of instructions names as names for macros and symbols. This\nmakes it possible to \"overload\" instructions by defining a macro with the\nsame name. This does also make it possible to introduce hard to find errors\nin your code, so be careful!\n\n\n### `underline_in_numbers`\n\nAllow underlines within numeric constants. These may be used for grouping\nthe digits of numbers for easier reading.\nExample:\n```ca65\n  .feature        underline_in_numbers\n  .word           %1100001110100101\n  .word           %1100_0011_1010_0101    ; Identical but easier to read\n  \n```\n\n\n\nIt is also possible to specify features on the command line using the\n[`--feature`](https://cc65.github.io/doc/ca65.html#option--feature) command line option.\nThis is useful when translating sources written for older assemblers, when\nyou don't want to change the source code.\n\nAs an example, to translate sources written for Andre Fachats xa65\nassembler, the features\n\n\n\n  labels_without_colons, pc_assignment, loose_char_term\n  \n\n\n\nmay be helpful. They do not make ca65 completely compatible, so you may not\nbe able to translate the sources without changes, even when enabling these\nfeatures. However, I have found several sources that translate without\nproblems when enabling these features on the command line.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "org": {
      "documentation": "`.ORG`\n---\nStart a section of absolute code. The command is followed by a constant\nexpression that gives the new PC counter location for which the code is\nassembled. Use [`.RELOC`](https://cc65.github.io/doc/ca65.html#.RELOC) to switch back to\nrelocatable code.\n\nBy default, absolute/relocatable mode is global (valid even when switching\nsegments). Using `.FEATURE [org_per_seg](https://cc65.github.io/doc/ca65.html#org_per_seg)`\nit can be made segment local.\n\nPlease note that you _do not need_ `.ORG` in most cases. Placing\ncode at a specific address is the job of the linker, not the assembler, so\nthere is usually no reason to assemble code to a specific address.\n\nExample:\n\n\n```ca65\n  .org    $7FF            ; Emit code starting at $7FF\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "time": {
      "documentation": "`.TIME`\n---\nReading this pseudo variable will give a constant integer value that\nrepresents the current time in POSIX standard (as seconds since the\nEpoch).\n\nIt may be used to encode the time of translation somewhere in the created\ncode.\n\nExample:\n\n\n```ca65\n  .dword  .time   ; Place time here\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "isize": {
      "documentation": "`.ISIZE`\n---\nReading this pseudo variable will return the current size of the Index\nregister in bits.\n\nFor the 65816 instruction set .ISIZE will return either 8 or 16, depending\non the current size of the operand in immediate index addressing mode.\n\nFor all other CPU instruction sets, .ISIZE will always return 8.\n\nSee also: [`.ASIZE`](https://cc65.github.io/doc/ca65.html#.ASIZE)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "const": {
      "documentation": "`.CONST`\n---\nBuiltin function. The function evaluates its argument in parentheses and\nyields \"true\" if the argument is a constant expression (that is, an\nexpression that yields a constant value at assembly time) and \"false\"\notherwise. As an example, the .IFCONST statement may be replaced by\n\n\n```ca65\n  .if     .const(a + 3)\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "p816": {
      "documentation": "`.P816`\n---\nEnable the 65816 instruction set. This is a superset of the 65SC02 and\n6502 instruction sets.\n\nSee: [`.P02`](https://cc65.github.io/doc/ca65.html#.P02), [`.PSC02`](https://cc65.github.io/doc/ca65.html#.PSC02), [`.PC02`](https://cc65.github.io/doc/ca65.html#.PC02) and\n[`.P4510`](https://cc65.github.io/doc/ca65.html#.P4510)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "setcpu": {
      "documentation": "`.SETCPU`\n---\nSwitch the CPU instruction set. The command is followed by a string that\nspecifies the CPU. Possible values are those that can also be supplied to\nthe [`--cpu`](https://cc65.github.io/doc/ca65.html#option--cpu) command line option,\nnamely: 6502, 6502X, 6502DTV, 65SC02, 65C02, 65816, 4510 and HuC6280.\n\nSee: [`.CPU`](https://cc65.github.io/doc/ca65.html#.CPU),\n[`.IFP02`](https://cc65.github.io/doc/ca65.html#.IFP02),\n[`.IFPDTV`](https://cc65.github.io/doc/ca65.html#.IFPDTV),\n[`.IFP816`](https://cc65.github.io/doc/ca65.html#.IFP816),\n[`.IFPC02`](https://cc65.github.io/doc/ca65.html#.IFPC02),\n[`.IFPSC02`](https://cc65.github.io/doc/ca65.html#.IFPSC02),\n[`.P02`](https://cc65.github.io/doc/ca65.html#.P02),\n[`.P816`](https://cc65.github.io/doc/ca65.html#.P816),\n[`.P4510`](https://cc65.github.io/doc/ca65.html#.P4510),\n[`.PC02`](https://cc65.github.io/doc/ca65.html#.PC02),\n[`.PSC02`](https://cc65.github.io/doc/ca65.html#.PSC02)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "pushcharmap": {
      "documentation": "`.PUSHCHARMAP`\n---\nPush the currently active character mapping onto a stack. The stack has a size of 16\nentries.\n\n`.PUSHCHARMAP` allows together with [`.POPCHARMAP`](https://cc65.github.io/doc/ca65.html#.POPCHARMAP) to switch to another character mapping and to restore the old\ncharacter mapping later, without knowledge of the current mapping.\n\nThe assembler will print an error message if the character mapping stack is already full,\nwhen this command is issued.\n\nSee: [`.CHARMAP`](https://cc65.github.io/doc/ca65.html#.CHARMAP), [`.POPCHARMAP`](https://cc65.github.io/doc/ca65.html#.POPCHARMAP)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "local": {
      "documentation": "`.LOCAL`\n---\nThis command may only be used inside a macro definition. It declares a\nlist of identifiers as local to the macro expansion.\n\nA problem when using macros are labels: Since they don't change their name,\nyou get a \"duplicate symbol\" error if the macro is expanded the second time.\nLabels declared with [`.LOCAL`](https://cc65.github.io/doc/ca65.html#.LOCAL) have their\nname mapped to an internal unique name (`___ABCD__`) with each macro\ninvocation.\n\nSome other assemblers start a new lexical block inside a macro expansion.\nThis has some drawbacks however, since that will not allow _any_ symbol\nto be visible outside a macro, a feature that is sometimes useful. The\n[`.LOCAL`](https://cc65.github.io/doc/ca65.html#.LOCAL) command is in my eyes a better way\nto address the problem.\n\nYou get an error when using [`.LOCAL`](https://cc65.github.io/doc/ca65.html#.LOCAL) outside\na macro.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "align": {
      "documentation": "`.ALIGN`\n---\nAlign data to a given boundary. The command expects a constant integer\nargument in the range 1 ... 65536, plus an optional second argument\nin byte range. If there is a second argument, it is used as fill value,\notherwise the value defined in the linker configuration file is used\n(the default for this value is zero).\n\n`.ALIGN` will insert fill bytes, and the number of fill bytes depend of\nthe final address of the segment. `.ALIGN` cannot insert a variable\nnumber of bytes, since that would break address calculations within the\nmodule. So each `.ALIGN` expects the segment to be aligned to a multiple\nof the alignment, because that allows the number of fill bytes to be\ncalculated in advance by the assembler. You are therefore required to\nspecify a matching alignment for the segment in the linker config. The\nlinker will output a warning if the alignment of the segment is less than\nwhat is necessary to have a correct alignment in the object file.\n\nExample:\n\n\n```ca65\n  .align  256\n  \n```\n\n\n\nSome unexpected behaviour might occur if there are multiple `.ALIGN`\ncommands with different arguments. To allow the assembler to calculate the\nnumber of fill bytes in advance, the alignment of the segment must be a\nmultiple of each of the alignment factors. This may result in unexpectedly\nlarge alignments for the segment within the module.\n\nExample:\n\n\n```ca65\n  .align  15\n  .byte   15\n  .align  18\n  .byte   18\n  \n```\n\n\n\nFor the assembler to be able to align correctly, the segment must be aligned\nto the least common multiple of 15 and 18 which is 90. The assembler will\ncalculate this automatically and will mark the segment with this value.\n\nUnfortunately, the combined alignment may get rather large without the user\nknowing about it, wasting space in the final executable. If we add another\nalignment to the example above\n\n\n```ca65\n  .align  15\n  .byte   15\n  .align  18\n  .byte   18\n  .align  251\n  .byte   0\n  \n```\n\n\n\nthe assembler will force a segment alignment to the least common multiple of\n15, 18 and 251 - which is 22590. To protect the user against errors, when the\ncombined alignment is larger than the explicitly requested alignments,\nthe assembler will issue a warning if it also exceeds 256. The command line\noption [`--large-alignment`](https://cc65.github.io/doc/ca65.html#option--large-alignment)\nwill disable this warning.\n\nPlease note that with only alignments that are a power of two, a warning will\nnever occur, because the least common multiple of powers to the same base is\nalways simply the larger one.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "undefine": {
      "documentation": "`.UNDEF, .UNDEFINE`\n---\nDelete a define style macro definition. The command is followed by an\nidentifier which specifies the name of the macro to delete. Macro\nreplacement is switched of when reading the token following the command\n(otherwise the macro name would be replaced by its replacement list).\n\nSee also the [`.DEFINE`](https://cc65.github.io/doc/ca65.html#.DEFINE) command and\nsection \n[Macros](https://cc65.github.io/doc/ca65.html#macros).\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "endunion": {
      "documentation": "`.ENDUNION`\n---\nEnds a union definition. See the [`.UNION`](https://cc65.github.io/doc/ca65.html#.UNION)\ncommand and the separate section named \n[Structs   and unions](https://cc65.github.io/doc/ca65.html#structs).\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "condes": {
      "documentation": "`.CONDES`\n---\nExport a symbol and mark it in a special way. The linker is able to build\ntables of all such symbols. This may be used to automatically create a list\nof functions needed to initialize linked library modules.\n\nNote: The linker has a feature to build a table of marked routines, but it\nis your code that must call these routines, so just declaring a symbol with\n`.CONDES` does nothing by itself.\n\nAll symbols are exported as an absolute (16 bit) symbol. You don't need to\nuse an additional [`.EXPORT`](https://cc65.github.io/doc/ca65.html#.EXPORT) statement, this\nis implied by `.CONDES`.\n\n`.CONDES` is followed by the type, which may be `constructor`,\n`destructor` or a numeric value between 0 and 6 (where 0 is the same as\nspecifying `constructor` and 1 is equal to specifying `destructor`).\nThe [`.CONSTRUCTOR`](https://cc65.github.io/doc/ca65.html#.CONSTRUCTOR), [`.DESTRUCTOR`](https://cc65.github.io/doc/ca65.html#.DESTRUCTOR) and [`.INTERRUPTOR`](https://cc65.github.io/doc/ca65.html#.INTERRUPTOR) commands are actually shortcuts for `.CONDES`\nwith a type of `constructor` resp. `destructor` or `interruptor`.\n\nAfter the type, an optional priority may be specified. Higher numeric values\nmean higher priority. If no priority is given, the default priority of 7 is\nused. Be careful when assigning priorities to your own module constructors\nso they won't interfere with the ones in the cc65 library.\n\nExample:\n\n\n```ca65\n  .condes         ModuleInit, constructor\n  .condes         ModInit, 0, 16\n  \n```\n\n\n\nSee the [`.CONSTRUCTOR`](https://cc65.github.io/doc/ca65.html#.CONSTRUCTOR), [`.DESTRUCTOR`](https://cc65.github.io/doc/ca65.html#.DESTRUCTOR) and [`.INTERRUPTOR`](https://cc65.github.io/doc/ca65.html#.INTERRUPTOR) commands and the separate section \n[Module constructors/destructors](https://cc65.github.io/doc/ca65.html#condes) explaining the feature in more\ndetail.\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "faraddr": {
      "documentation": "`.FARADDR`\n---\nDefine far (24 bit) address data. The command must be followed by a\nsequence of (not necessarily constant) expressions.\n\nExample:\n\n\n```ca65\n  .faraddr        DrawCircle, DrawRectangle, DrawHexagon\n  \n```\n\n\n\nSee: [`.ADDR`](https://cc65.github.io/doc/ca65.html#.ADDR)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "endscope": {
      "documentation": "`.ENDSCOPE`\n---\nEnd of the local lexical level (see [`.SCOPE`](https://cc65.github.io/doc/ca65.html#.SCOPE)).\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "exportzp": {
      "documentation": "`.EXPORTZP`\n---\nMake symbols accessible from other modules. Must be followed by a comma\nseparated list of symbols to export. The exported symbols are explicitly\nmarked as zero page symbols. An assignment may be included in the\n`.EXPORTZP` statement. This allows to define and export a symbol in one\nstatement.\n\nExamples:\n\n\n```ca65\n  .exportzp  foo, bar\n  .exportzp  baz := $02\n  \n```\n\n\n\nSee: [`.EXPORT`](https://cc65.github.io/doc/ca65.html#.EXPORT)\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "hiword": {
      "documentation": "`.HIWORD`\n---\nThe function returns the high word (that is, bits 16-31) of its argument.\n\nSee: [`.LOWORD`](https://cc65.github.io/doc/ca65.html#.LOWORD)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "pushseg": {
      "documentation": "`.PUSHSEG`\n---\nPush the currently active segment onto a stack. The entries on the stack\ninclude the name of the segment and the segment type. The stack has a size\nof 16 entries.\n\n`.PUSHSEG` allows together with [`.POPSEG`](https://cc65.github.io/doc/ca65.html#.POPSEG)\nto switch to another segment and to restore the old segment later, without\neven knowing the name and type of the current segment.\n\nThe assembler will print an error message if the segment stack is already\nfull, when this command is issued.\n\nSee: [`.POPSEG`](https://cc65.github.io/doc/ca65.html#.POPSEG)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "lobyte": {
      "documentation": "`.LOBYTE`\n---\nThe function returns the low byte (that is, bits 0-7) of its argument.\nIt works identical to the '<' operator.\n\nSee: [`.HIBYTE`](https://cc65.github.io/doc/ca65.html#.HIBYTE),\n[`.BANKBYTE`](https://cc65.github.io/doc/ca65.html#.BANKBYTE)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "hibyte": {
      "documentation": "`.HIBYTE`\n---\nThe function returns the high byte (that is, bits 8-15) of its argument.\nIt works identical to the '>' operator.\n\nSee: [`.LOBYTE`](https://cc65.github.io/doc/ca65.html#.LOBYTE),\n[`.BANKBYTE`](https://cc65.github.io/doc/ca65.html#.BANKBYTE)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "zeropage": {
      "documentation": "`.ZEROPAGE`\n---\nSwitch to the ZEROPAGE segment and mark it as direct (zeropage) segment.\nThe name of the ZEROPAGE segment is always \"ZEROPAGE\", so this is a\nshortcut for\n\n\n```ca65\n  .segment  \"ZEROPAGE\": zeropage\n  \n```\n\n\n\nBecause of the \"zeropage\" attribute, labels declared in this segment are\naddressed using direct addressing mode if possible. You _must_ instruct\nthe linker to place this segment somewhere in the address range 0..$FF\notherwise you will get errors.\n\nSee: [`.SEGMENT`](https://cc65.github.io/doc/ca65.html#.SEGMENT)\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "end": {
      "documentation": "`.END`\n---\nForced end of assembly. Assembly stops at this point, even if the command\nis read from an include file.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "if": {
      "documentation": "`.IF`\n---\nConditional assembly: Evaluate an expression and switch assembler output\non or off depending on the expression. The expression must be a constant\nexpression, that is, all operands must be defined.\n\nA expression value of zero evaluates to FALSE, any other value evaluates\nto TRUE.\n\n",
      "snippet_type": "ca65_if_param"
    },
    "charmap": {
      "documentation": "`.CHARMAP`\n---\nApply a custom mapping for characters for the commands [`.ASCIIZ`](https://cc65.github.io/doc/ca65.html#.ASCIIZ) and [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE). The command\nis followed by two numbers. The first one is the index of the source character\n(range 0..255);\nthe second one is the mapping (range 0..255). The mapping applies to all\ncharacter and string constants _when_ they generate output; and, overrides\na mapping table specified with the [`-t`](https://cc65.github.io/doc/ca65.html#option-t)\ncommand line switch.\n\nExample:\n```ca65\n  .charmap        $41, $61        ; Map 'A' to 'a'\n  \n```\n\n\n\n",
      "snippet_type": "ca65_keyword_space"
    },
    "string": {
      "documentation": "`.STRING`\n---\nBuiltin function. The function accepts an argument in parentheses and converts\nthis argument into a string constant. The argument may be an identifier, or\na constant numeric value.\n\nSince you can use a string in the first place, the use of the function may\nnot be obvious. However, it is useful in macros, or more complex setups.\n\nExample:\n\n\n```ca65\n  ; Emulate other assemblers:\n  .macro  section name\n          .segment        .string(name)\n  .endmacro\n  \n```\n\n\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "referenced": {
      "documentation": "`.REF, .REFERENCED`\n---\nBuiltin function. The function expects an identifier as argument in parentheses.\nThe argument is evaluated, and the function yields \"true\" if the identifier\nis a symbol that has already been referenced somewhere in the source file up\nto the current position. Otherwise the function yields false. As an example,\nthe [`.IFREF`](https://cc65.github.io/doc/ca65.html#.IFREF) statement may be replaced by\n\n\n```ca65\n  .if     .referenced(a)\n  \n```\n\n\n\nSee: [`.DEFINED`](https://cc65.github.io/doc/ca65.html#.DEFINED)\n\n",
      "snippet_type": "ca65_pseudo_function"
    },
    "bss": {
      "documentation": "`.BSS`\n---\nSwitch to the BSS segment. The name of the BSS segment is always \"BSS\",\nso this is a shortcut for\n\n\n```ca65\n  .segment  \"BSS\"\n```\n\n\n\nSee also the [`.SEGMENT`](https://cc65.github.io/doc/ca65.html#.SEGMENT) command.\n\n",
      "snippet_type": "ca65_keyword_newline"
    },
    "proc": {
      "documentation": "`.PROC`\n---\nStart a nested lexical level with the given name and adds a symbol with this\nname to the enclosing scope. All new symbols from now on are in the local\nlexical level and are accessible from outside only via \n[explicit scope specification](https://cc65.github.io/doc/ca65.html#scopesyntax). Symbols defined outside this local\nlevel may be accessed as long as their names are not used for new symbols\ninside the level. Symbols names in other lexical levels do not clash, so you\nmay use the same names for identifiers. The lexical level ends when the\n[`.ENDPROC`](https://cc65.github.io/doc/ca65.html#.ENDPROC) command is read. Lexical levels\nmay be nested up to a depth of 16 (this is an artificial limit to protect\nagainst errors in the source).\n\nNote: Macro names are always in the global level and in a separate name\nspace. There is no special reason for this, it's just that I've never\nhad any need for local macro definitions.\n\nExample:\n\n\n```ca65\n  .proc   Clear           ; Define Clear subroutine, start new level\n          lda     #$00\n  L1:     sta     Mem,y   ; L1 is local and does not cause a\n                          ; duplicate symbol error if used in other\n                          ; places\n          dey\n          bne     L1      ; Reference local symbol\n          rts\n  .endproc                ; Leave lexical level\n  \n```\n\n\n\nSee: [`.ENDPROC`](https://cc65.github.io/doc/ca65.html#.ENDPROC) and [`.SCOPE`](https://cc65.github.io/doc/ca65.html#.SCOPE)\n\n",
      "snippet_type": "ca65_keyword_block"
    },
    "out": {
      "documentation": "`.OUT`\n---\nOutput a string to the console without producing an error. This command\nis similar to `.ERROR`, however, it does not force an assembler error\nthat prevents the creation of an object file.\n\nExample:\n\n\n```ca65\n  .out    \"This code was written by the codebuster(tm)\"\n  \n```\n\n\n\nSee also: [`.ERROR`](https://cc65.github.io/doc/ca65.html#.ERROR),\n[`.FATAL`](https://cc65.github.io/doc/ca65.html#.FATAL),\n[`.WARNING`](https://cc65.github.io/doc/ca65.html#.WARNING)\n\n",
      "snippet_type": "ca65_keyword_string"
    },
    "bankbytes": {
      "documentation": "`.BANKBYTES`\n---\nDefine byte sized data by extracting only the bank byte (that is, bits 16-23) from\neach expression.  This is equivalent to [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE) with\nthe operator '^' prepended to each expression in its list.\n\nExample:\n\n\n```ca65\n  .define MyTable TableItem0, TableItem1, TableItem2, TableItem3\n\n  TableLookupLo:   .lobytes   MyTable\n  TableLookupHi:   .hibytes   MyTable\n  TableLookupBank: .bankbytes MyTable\n  \n```\n\n\n\nwhich is equivalent to\n\n\n```ca65\n  TableLookupLo:   .byte <TableItem0, <TableItem1, <TableItem2, <TableItem3\n  TableLookupHi:   .byte >TableItem0, >TableItem1, >TableItem2, >TableItem3\n  TableLookupBank: .byte ^TableItem0, ^TableItem1, ^TableItem2, ^TableItem3\n  \n```\n\n\n\nSee also: [`.BYTE`](https://cc65.github.io/doc/ca65.html#.BYTE),\n[`.HIBYTES`](https://cc65.github.io/doc/ca65.html#.HIBYTES),\n[`.LOBYTES`](https://cc65.github.io/doc/ca65.html#.LOBYTES)\n\n",
      "snippet_type": "ca65_keyword_space"
    }
  },
  "keys_with_shared_doc": {
    "mac": "macro",
    "exitmac": "exitmacro",
    "endrep": "endrepeat",
    "byt": "byte",
    "undef": "undefine",
    "ismnem": "ismnemonic",
    "def": "defined",
    "ref": "referenced",
    "pagelen": "pagelength",
    "refto": "referto",
    "endmac": "endmacro",
    "delmac": "delmacro",
    "fileopt": "fopt"
  }
}