{
  "generic": "`generic`\n---\nThis macro package defines macros that are useful in almost any program.\n\nCurrently defined macros are:\n\n```ca65\n  .macro  add  Arg  ; add without carry\n          clc\n          adc  Arg\n  .endmacro\n  .macro  sub  Arg  ; subtract without borrow\n          sec\n          sbc  Arg\n  .endmacro\n  .macro  bge  Arg  ; branch on greater-than or equal\n          bcs  Arg\n  .endmacro\n  .macro  blt  Arg  ; branch on less-than\n          bcc  Arg\n  .endmacro\n  .macro  bgt  Arg  ; branch on greater-than\n          .local  L\n          beq  L\n          bcs  Arg\n  L:\n  .endmacro\n  .macro  ble  Arg  ; branch on less-than or equal\n          beq  Arg\n          bcc  Arg\n  .endmacro\n\n  .macro  bnz  Arg  ; branch on not zero\n          bne  Arg\n  .endmacro\n\n  .macro  bze  Arg  ; branch on zero\n          beq  Arg\n  .endmacro\n```",
  "longbranch": "`longbranch`\n---\\nThis macro package defines long conditional jumps. They are named like the short counterpart but with the 'b' replaced by a 'j'. Here is a sample definition for the \"`jeq`\" macro, the other macros are built using the same scheme:\n\n```ca65\n  .macro  jeq  Target\n          .if     .def(Target) .and ((*+2)-(Target) &lt;= 127)\n          beq  Target\n          .else\n          bne     *+5\n          jmp  Target\n          .endif\n  .endmacro\n```\n\\nAll macros expand to a short branch, if the label is already defined (back jump) and is reachable with a short jump. Otherwise the macro expands to a conditional branch with the branch condition inverted, followed by an absolute jump to the actual branch target.\n\\nThe package defines the following macros:\n\n```\n  jeq, jne, jmi, jpl, jcs, jcc, jvs, jvc\n```"
}